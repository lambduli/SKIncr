(module StdLib imports ())

(vars ())

(functions (
  #define polyvariadic function for list construction

  # a "trick", we returns the varargs
  (function list (...args) args)

  (function at (lst i) ( builtin_bin "at" lst i ))

  (function drop (n lst)
    (begin
      (let res 0)
      (if (== n 0)
          (set! res lst)
          (set! res (drop (- n 1) (tail lst))))
          res
    )
  )

  # define all the builtin_* as "built-in"
  (function builtin_bin (op x y) 0)
  (function builtin_un (op x) 0)
  (function builtin_nul (op) 0)

  # we need it, because we treat the set! statement as a function call
  (function set! (x expr) 0)

  # functions on lists
  (function head (lst) ( builtin_un "head" lst ))
  (function tail (lst) ( builtin_un "tail" lst ))
  (function size (lst) ( builtin_un "size" lst ))

  # functions on arrays
  (function array (...elements) (builtin_un "array" elements) )
  (function arr_set! (arr idx val) 0)
  (function arr_get (arr idx) (builtin_bin "arr_get" arr idx))
  (function arr_length (arr) (builtin_un "arr_length" arr))

  # number airthmetics
  (function + (x y) ( builtin_bin "+" x y ))
  (function - (x y) ( builtin_bin "-" x y ))
  (function * (x y) ( builtin_bin "*" x y ))
  (function / (x y) ( builtin_bin "/" x y ))

  # boolean airthmetics
  (function ! (x) ( builtin_un "!" x ))
  (function && (x y) ( builtin_bin "&&" x y ))
  (function || (x y) ( builtin_bin "||" x y ))

  # numeric ordering
  (function < (x y) ( builtin_bin "<" x y ))
  (function > (x y) ( builtin_bin ">" x y ))
  (function <= (x y) ( builtin_bin "<=" x y ))
  (function >= (x y) ( builtin_bin ">=" x y ))

  # universal comparison
  (function == (x y) ( builtin_bin "==" x y ))

  # IO
  (function write! (msg ...x) ( builtin_bin "write!" msg x ))
  (function read! () ( builtin_nul "read!" ))

  # assert
  (function assert! (value msg) ( builtin_bin "assert!" value msg ) )
))
