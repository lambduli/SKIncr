module Reader;
// =====================================================================================================
// Small is a miniature parenthesized imperative, first-order, eager
// language.
//
// This file contains the handwritten parser and lexer for Small,
// along with a checker. The entry point is the Reader class.  From
// this class you will get an AST with source references to each input
// file.

// Small Grammar:
//
// File ::= (module Ident imports (Ident+))  (vars (Decl+))  (functions (Function+))
// Decl ::= (let Ident Expr)
// Function ::= (function Ident(Args) Expr)
// Args ::= Ident+ [`...`Ident]
// Expr ::=  LitInt | LitBool | LitString | LitChar
//        |  Ident
//        |  Cond
//        |  While
//        |  Decl
//        |  Block
//        |  Call
// Call ::= (Ident Expr*)
// Cond ::= (if Expr Expr Expr)
// Block ::= (begin Expr* )
// While ::= (while Expr Expr)

// A Small program is a collection of `File`s. The following 9 rules
// are checked.

// ✔ (R1) each `File` must have a unique name.  Each `File`, exports its
// functions and keeps its global variables private.  Each `File`
// imports other `File`s and `StdLib`.

// ✔ (R2) Two imported files cannot export the same function name, or
// shadow a local function.

// ✔ (R3) Variable names in scope cannot shadow one other.

// ✔ (R4) All variable references must refer to previously defined
// variables.

// ✔ (R5) All function calls must be to defined functions with the
// correct arity.

// Small has a number of special forms handled differently than expressions.

// Statement-like terms: (let), (set!), (while) do not return a value
// and can only occur at the top-level.

// Terms: (if) and (begin) can have a return value, but still must
// occur at the top level.

// The `top-level` refers to the body of a function, the branches of
// an if, or the body of a loop.

// (begin  (if a (begin (set! x 1) x) (+ z 2))) is fine but
// (if (if x y z) ...) is not because the guard of an if is not top-level.
//
// (R6) (let), (set!), (arr_set!) (while), (if), (begin) must occur at the
// top-level.
//
// Every function should return a value. Thus every top-level code
// path must end in an expression or a value-returning term.
//
// ✔ (R7) Check that functions are not terminated by non-value-returning terms.

// ✔ (R8) Each file cannot have an `init` function (one will be provided)

// ✔ (R9) Each program must have a single `main` function.

// =====================================================================================================

// Shorthands
type Names = Vector<Name>;
type Expressions = Vector<Expr>;
type Tokens = Vector<Tok>;
type Chars = Vector<Char>;
type Strings = Vector<String>;
type Declarations = Vector<Decl>;
type Files = Vector<File>;
type Functions = Vector<Function>;


// -------------------------------------------------------------------------------------
// ---------------------- ABSTRACT SYNTAX TREE -----------------------------------------
// -------------------------------------------------------------------------------------

// A file that contains .sm code
value class File(tok: Tok, name: String, imports: Strings, decls: Declarations, funs: Functions) {
}

// A .sm function
value class Function(
			tok: Tok,
			name: String,
			params: Strings,
 			polyArg: Option<String>,
			body: Expr,
			locals: Int
		) {}

// The core of the AST is the Expr type with its children.
base class Expr {
  children =
  | LitInt(Tok, Int)
  | LitBool(Tok, Bool)
  | LitString(Tok, String)
  | LitChar(Tok, Char)
  | Var(Tok, name: String)
  | Decl(Tok, String, Expr)
  | Call(Tok, String, Expressions)
  | Block(Tok, Expressions)
  | While(Tok, Expr, Expr)
  | Cond(Tok, Expr, Expr, Expr)

  fun getToken(): Tok {
    this match {
      | LitInt(t, _)
      | LitBool(t, _)
      | LitString(t, _)
      | LitChar(t, _)
      | Var(t, _)
      | Decl(t, _, _)
      | Call(t, _, _)
      | Block(t, _)
      | While(t, _, _)
      | Cond(t, _, _, _) -> t
    }
  }
}


mutable class .ASTPrettyPrint(mutable indent: Int = 0) {

  static fun prettyPrint(f: File): String {
    pp = mutable ASTPrettyPrint();
    pp.file( f )
  }

  mutable fun file(f: File): String {
     s = `(module ${f.name} imports (`;
     f.imports.each(s -> !s = s + s + " ");
     !s = `${s})\n(vars (`;
     if (f.decls.size() == 0) {
       !s = s + "))\n";
     } else {
       this.inc();
       f.decls.each(d -> !s = s + "\n" + this.pad() + this.expression(d));
       this.dec();
       !s = s + "\n))\n";
     };
     !s = s + `(functions (`;
     if (f.funs.size() == 0) {
       !s = s + "))\n";
     } else {
       this.inc();
       f.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
        !s = s + "\n))\n";
       this.dec();
     };
     s
  }

  mutable fun function(f: Function): String {
    s = `(function ${f.name}(`;
    f.params.each(p -> !s = `${s} ${p}`);
    _ = f.polyArg.map(str -> { !s = `${s} ...${str}`});
    !s = `${s}) `;
    this.inc();
    !s = `${s} ${this.expression(f.body)}\n`;
    this.dec();
    s
  }

  mutable fun expression(e0: Expr): String {
    e0 match {
    | LitInt(_, i) -> `${i}`
    | LitBool(_, b) -> `${b}`
    | LitChar(_, ch) -> `'${ch}'`
    | LitString(_, str) -> `"${str}"`
    | Var(_, s) -> { s }
    | Decl(_, n, e) -> `(let ${n} ${this.expression(e)})`
    | Call(_, n, es) -> `(${n} ${es.map(e -> this.expression(e)).join( " " )})`
    | Block(_t, es) -> {
      s = `${this.pad()}(begin `;
      this.inc();
      es.each(e -> !s = `${s}\n${this.pad()}${this.expression(e)}`);
      this.dec();
      `${s})`
    }
    | While(_, e, s) -> `(while ${this.expression(e)} ${this.expression(s)})`
		| Cond(_, e, s1, s2) -> {
      s = `(if ${this.expression(e)}\n`;
      this.inc();
      !s = `${s}${this.expression(s1)}\n${this.expression(s2)})`;
      this.dec();
      s
    }
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }
  readonly fun pad(): String { s = ""; n = this.indent; while (n > 0) { !s = s+" "; !n = n-1; }; s }

}


// ----------------------------------------------------------------------------------
// Reader
//
// Interface to keep track of a file, its source text, parsed output, and any error.
//
// Does not throw exceptions.
//
// Some issues/questions:
// ?? The dot in front of the name is a trick to make the class visible at the top ??
// ?? Is there a way to have private fields? ??
// ?? !this.f = 1   ||   this.!f = 1  ??
// skiplang documentation still has .get method on String
// ----------------------------------------------------------------------------------
mutable class .Reader{
  path: String,                 // path to the target file
  text: Chars = Chars[],        // contents of the file
  mutable tokens: mutable Tokens = mutable Tokens[], // stream of lexed tokens
  mutable tokPos: Int = 0,      // position in the token stream
  mutable ok: Bool = true,      // was there any error processing
  mutable error: String = "",   // message to report to the user
  mutable pos: Int = 0,         // current offset in the text
  mutable lineBreak: Int = 0,   // last line break offset seen
  mutable lines: Int = 0} {     // number of lines so far

  // create: returns a new reader for the provided file.
  static fun create(p: String): mutable Reader {
    if (!FileSystem.exists(p)) return mutable Reader{path=>p, ok=>false, error=>`File ${p} not found`};
    r = mutable Reader{path=>p, text=>FileSystem.readTextFile(p).chars(), tokens=>mutable Tokens[]};
    r.!tokens = r.lex();
    r
  }

  // process: given a list of files, parses and check them
  static fun process(paths: Strings): (Vector<mutable Reader>, Files) {
    rs = paths.map(p -> Reader::create(p)); // Readers
    fs = rs.map(r -> r.file()); // Parsed files
    fail = false;
    rs.each(r -> if (!r.ok) { r.reportError(); !fail = true; });
    if (fail) return (Vector[], Vector[]);
    i = 0;
    while (i < rs.size()) {
			Checker::create(rs[i]).file(fs[i], fs);
      !i = i + 1;
    };
    (rs, fs)
  }

  // ------------- PARSING -----------------------------------------------------

  // Parse a file, always returns something. Clients check the Reader for an error.
  mutable fun file(): File {
    tok = this.curToken();
    (name, _)    = (this.eat("(").eat("module").identifier(), this.eat("imports").eat("("));
    (imports, _) = (this.identifiers(), this.eat(")").eat(")").eat("(").eat("vars").eat("("));
    (decls, _)   = (this.declarations(), this.eat(")").eat(")").eat("(").eat("functions").eat("("));
    (funs, _)    = (this.functions(), this.eat(")").eat(")"));
    File(Tok::createFrom(tok, this.curToken().end, this), name, imports, decls, funs)
  }

  // Parse an expression.
  mutable fun expression(): Expr {
    tok = this.curToken();
    if (!this.ok) return Var(tok, "ERR");
    stok = tok.asString();
    if (stok == "(")
      this.nextToken().asString() match {
      |   "let" -> this.declaration()
      | "begin" -> this.block()
      | "while" -> this.whileLoop()
      |    "if" -> this.cond()
      |       _ -> this.call()
      }
    else {
      if      (this.isInt(tok))    { this.advanceTok(); LitInt(tok,    this.asInt(tok))     }
      else if (this.isBool(tok))   { this.advanceTok(); LitBool(tok,   this.asBool(tok))    }
      else if (this.isChar(tok))   { this.advanceTok(); LitChar(tok,   this.asChar(tok))    }
      else if (this.isString(tok)) { this.advanceTok(); LitString(tok, this.asString(tok))  }
      else Var(tok, this.identifier())
    }
  }

  // Parse a function declaration: (function name (params...) exp)
  mutable fun function(): Function {
    tok = this.curToken();
    (name, _, params) = (this.eat("(").eat("function").identifier(), this.eat("("), this.identifiers());
    (vargs, _, exp, _) = (this.maybeVarArg(), this.eat(")"), this.expression(), this.eat(")"));
    Function(Tok::createFrom(tok, this.curToken().end, this), name, params, vargs, exp, 0)
  }

  // Parse a let binding: (let name exp)
  mutable fun declaration(): Decl {
    tok = this.curToken();
    (name, expr, _) = (this.eat("(").eat("let").identifier(), this.expression(), this.eat(")"));
    Decl(Tok::createFrom(tok, this.curToken().end, this), name, expr)
  }

  mutable fun block(): Block {
    tok = this.curToken();
    (_, exprs, _) = (this.eat("(").eat("begin"), this.expressions(), this.eat(")"));
    Block(Tok::createFrom(tok, this.curToken().end, this), exprs)
  }

  mutable fun whileLoop(): While {
    tok = this.curToken();
    (_, e, b, _) = (this.eat("(").eat("while"), this.expression(), this.expression(), this.eat(")"));
    While(Tok::createFrom(tok, this.curToken().end, this), e, b)
  }

  mutable fun cond(): Cond {
    tok = this.curToken();
    _ = this.eat("(").eat("if");
    (c, t, f, _) = (this.expression(), this.expression(), this.expression(), this.eat(")"));
    Cond(Tok::createFrom(tok, this.curToken().end, this), c, t, f)
  }

  mutable fun call(): Call {
    tok = this.curToken();
    (name, exprs, _) = (this.eat("(").identifier(), this.expressions(), this.eat(")"));
    Call(Tok::createFrom(tok, this.curToken().end, this), name, exprs)
  }

  // Parse the optional var-args form: (function f (a b c ...d) body)
	// where `...d` gives name `d` to a possible empty list of arguments.
  mutable fun maybeVarArg(): Option<String> {
    if (this.isNext("...")) {
      _ = this.eat("...");
      Some(this.identifier())
    } else {
      None()
    }
  }

  mutable fun identifiers(): Strings {
    vec = mutable Strings[];
    while (this.ok && !(this.isNext(")") || this.isNext("..."))) vec.push(this.identifier());
    vec.chill()
  }

  mutable fun expressions(): Expressions {
    vec = mutable Expressions[];
    while (this.ok && !this.isNext(")")) vec.push(this.expression());
    vec.chill()
  }

  // Parse declarations
  mutable fun declarations(): Declarations {
    vec = mutable Declarations[];
    while (this.ok && !this.isNext(")")) vec.push(this.declaration());
    vec.chill()
  }

  // Parse functions
  mutable fun functions(): Functions {
    vec = mutable Functions[];
    while (this.ok && !this.isNext(")")) vec.push(this.function());
    vec.chill()
  }

 // Is the given string the next token?
  mutable fun isNext(s: String): Bool { this.ok && this.hasMoreTokens() && this.curToken().asString() == s }

  // Do we have more tokens?
  readonly fun hasMoreTokens(): Bool { this.ok && this.tokPos < this.tokens.size(); }

  // Consume the requested token, or fail
  mutable fun eat(s: String): mutable Reader {
    if (this.ok && this.hasMoreTokens()) {
       tok = this.curToken();
      if (tok.asString() != s) this.fail(tok, `expected ${s}`);
      this.advanceTok();
    };
    this
  }

  // ------------------------------------------------------------------------
	// `fail(tok, msg)` takes a token, the position of the error, and a
	// string, the message describing the error. Given our lazy exit
	// strategy, we may `fail` multiple times for the same file; only
	// the first error is recorded.
  mutable fun fail(tok: Tok, msg: String): void {
	  if (this.ok) {
      this.!ok = false;
      this.!error = tok.error_message(msg);
  	}
  }

  // Return the previous token or the current one (approximate at the edge)
  readonly fun prevToken(): Tok {
    if (this.tokPos > 0) this.tokens[this.tokPos-1] else this.curToken()
  }

  // Return the current token, or a bad token if we are not in a good place
  readonly fun curToken(): Tok {
    if (this.ok && this.hasMoreTokens()) this.tokens[this.tokPos] else Tok()
  }

  // Returns the next token if available, otherwise fail and return garbage
  mutable fun nextToken(): Tok {
    if (this.tokPos +1 < this.tokens.size()) {
      this.tokens[this.tokPos+1]
    } else {
      this.fail(this.curToken(), "premature end of file");
      this.curToken()
    }
  }

  // advance the position in the token stream, possibly off the end
  mutable fun advanceTok(): void { this.!tokPos = this.tokPos + 1; }

  // Return an identifier and fail if this is not well-formed
  mutable fun identifier(): String {
	  if (!this.ok) { return "ERR"; };
    if (!this.hasMoreTokens()) this.fail(this.prevToken(), "premature end of file");
    tok = this.curToken();
    if (!this.isIdentifier(tok)) this.fail(tok, "expected an identifier");
	  if (!this.ok) { return "ERR"; };
    this.advanceTok();
    tok.asString()
  }

  // If an error occured report it.
  readonly fun reportError(): void { if (!this.ok) print_string(this.error); }

  // -------------- LEXING -----------------------------------------------------

  // Return the current char and advance cursor.
  mutable fun charNext(): Char {
		 if (this.pos >= this.text.size()) {
         this.fail(Tok(), "premature end of file");
				 return '\n'; // TODO perhaps retun EOF, it should not matter because we have failed()
		 };
     c = this.text[this.pos];
     this.!pos = this.pos + 1;
     c
  }

  // Unreads the last character
  mutable fun unread():void {
		 if (this.pos > 0) {
		   this.!pos = this.pos - 1;
		 } else {
		   this.fail(Tok(), "internal error: unread");
		 };
  }

  // Reader is ok and there is at least one more char.
  readonly fun hasMore(): Bool { this.ok && this.pos < this.text.size()  }

  // Process a file breaking it into tokens
  mutable fun lex(): mutable Tokens {
    toks = mutable Tokens[];
    this.skipSpaces();
    (cur, prev) = (Tok(), Tok());
    while(this.hasMore()) {
      !prev = cur;
      !cur = this.token();
      this.skipSpaces();
      if (!cur.isBad()) toks.push(cur) else this.fail(prev, "lexing failed");
    };
    toks
  }

  // Identifiers and operators
  readonly fun isLetterOrOp(c: Char): Bool {
    Chars.isDigit(c) || this.isLetter(c) || c == '='
    || c == '!' || c == '%' || c == '&' || c == '|' || c == '/' || c == '-'
    || c == '+' || c == '*' || c == '<' || c == '>' || c == '=' || c == '?'
  }

  readonly fun isLetter(c: Char): Bool { Chars.isUpperCaseLetter(c) || Chars.isLowerCaseLetter(c) || c == '_' }
  readonly fun isDelimiter(c: Char): Bool   { c == '(' || c == ')' || this.isSpace(c) || this.isLineBreak(c) }
  readonly fun isLineBreak(c: Char): Bool   { c == '\n' }
  readonly fun isSpace(c: Char): Bool       { c == ' ' || c == '\t' }
  readonly fun isComment(c: Char): Bool     { c == '#' }
  readonly fun isSingleQuote(c: Char): Bool { c == '\'' }
  readonly fun isDoubleQuote(c: Char): Bool { c == '\"' }
  readonly fun isPeriod(c: Char): Bool      { c ==  '.' }

  // Records the position of the line break and increase the number of lines seen
  mutable fun recordLineBreak(lastPos: Int): void {
    this.!lines = this.lines + 1;
    this.!lineBreak = lastPos;
  }

  // Skip a whole comment assuming we already read the leading #
  mutable fun skipComment(): void {
    while (this.hasMore()) {
      if (this.isLineBreak(this.charNext())) { this.recordLineBreak(this.pos - 1); break void; };
    }
  }

  // Move past comments and white spaces, while keeping track of line breaks.
  mutable fun skipSpaces(): void {
    while (this.hasMore()) {
      c = this.charNext();
      if (this.isComment(c)) this.skipComment()
      else if (this.isLineBreak(c)) this.recordLineBreak(this.pos - 1)
      else if (!this.isSpace(c)) {
        this.unread(); // we read one too many, return it back to the stream
        break void;
      };
    };
  }

  mutable fun token(): Tok {
    start = this.pos;
    c = this.charNext();
    if (Chars.isDigit(c)) this.readNumber(start)
    else if (this.isDelimiter(c)) Tok::createRange(start, start+1, this)
    else if (this.isSingleQuote(c)) this.readChar(start)
    else if (this.isDoubleQuote(c)) this.readString(start)
    else if (this.isPeriod(c)) this.readElipses(start)
    else if (this.isLetterOrOp(c)) this.readIdentifier(start)
    else Tok()
  }

  // Todo: add support for escape sequences
  mutable fun readChar(start: Int): Tok {
    if (!this.hasMore()) return Tok();
     _ = this.charNext();
    if (!this.hasMore()) return Tok();
     c = this.charNext();
    if (this.isSingleQuote(c)) Tok::createRange(start, start + 2, this) else Tok()
  }

  mutable fun readNumber(start: Int): Tok {
    while(this.hasMore()) {
      c = this.charNext();
      if (this.isDelimiter(c)) {
         this.unread();
         break void;
      }  else if (!Chars.isDigit(c)) return Tok();
    };
    Tok::createRange(start, this.pos, this)
 }

 // reads `...` (used in var args)
 mutable fun readElipses(start: Int): Tok {
  while(this.hasMore()) {
      c = this.charNext();
      if ( ! this.isPeriod(c)) { this.unread(); break void };
    };
    if (this.pos - start != 3) return Tok();
    Tok::createRange(start, this.pos, this)
 }

  mutable fun readString(start: Int): Tok {
    while(this.hasMore()) {
      c = this.charNext();
      if (this.isDoubleQuote(c)) break void
      else if (this.isLineBreak(c)) return Tok();
    };
    Tok::createRange(start, this.pos, this)
  }

  mutable fun readIdentifier(start: Int): Tok {
    while(this.hasMore()) {
      c = this.charNext();
      if (!this.isLetterOrOp(c) && !Chars.isDigit(c)) { this.unread(); break void };
    };
    Tok::createRange(start, this.pos, this)
  }


  // Supports booleans, integers, strings, and characters
  mutable fun isValue(t: Tok): Bool { this.isBool(t) || this.isInt(t) || this.isChar(t) || this.isString(t) }

  // A Bool value is either tt or ff
  mutable fun isBool(t: Tok): Bool {
    if (t.start + 2 != t.end) return false;
    txt = this.text;
    (a, b) =  (txt[t.start], txt[t.start+1]);
    (a == 't' && b == 't') || (a == 'f' && b == 'f')
  }

  // An integer starts with a digit (not that we don't support identifers starting with a digit)
  mutable fun isInt(t: Tok): Bool { Chars.isDigit(this.text[t.start]) }

  // A character is 'a'
  mutable fun isChar(t: Tok): Bool { this.isSingleQuote(this.text[t.start]) }

  // A string is "aa"
  mutable fun isString(t: Tok): Bool { this.isDoubleQuote(this.text[t.start]) }

  // tt and ff
  mutable fun asBool(t: Tok): Bool { this.text[t.start] == 't' && this.text[t.start+1] == 't' }

  mutable fun asInt(t: Tok): Int { t.asString().toInt() }

  mutable fun asString(t: Tok): String {
    t.stringFromSlice(t.start + 1, t.end - 1)
  }

  mutable fun asChar(t: Tok): Char {
    t.stringFromSlice(t.start + 1, t.end - 1).chars()[0]
  }

  // Some examples of valid identifiers:  a, a!, a?, _, _a, a1, +, <=
  mutable fun isIdentifier(t: Tok): Bool {
     if (this.isValue(t)) { return false; };
     (from, to) = (t.start, t.end);
     if (to - from == 1) {
         c =  this.text[from];
        this.isLetter(c)
				||c == '+'  || c == '*' || c == '-' || c == '!'
        || c == '/' || c == '%' || c == '<' || c == '>'
     } else if (to - from == 2) {
         (c, c2) =  (this.text[from], this.text[from+1]);
        if (this.isLetter(c)) {
          c2 == '!' || c2 == '?' || Chars.isDigit(c) || this.isLetter(c)
        } else {
             (c == '&' && c2 == '&') || (c == '|' && c2 == '|')
          || (c == '<' && c2 == '=') || (c == '>' && c2 == '=')
          || (c == '=' && c2 == '=')
       }
     } else {
       c = this.text[from];
       if (!this.isLetter(c)) return false;
       !from = from + 1;
        while(from < to) {
          ch = this.text[from];
          b = this.isLetter(ch) || ch == '!' || ch == '?';
          if (!b) return false;
          !from = from + 1;
        };
       true
     }
  }
}


// -------------------------------------------------------------------------------------------
// class Tok: tokens with references into the source file.
//
// start -- the position in the text file of the start of this token
// end   -- the position in the text file of the end of this token
// lines -- the line number, starting at 0, where this token occurs
// lineBreak -- the position of the previous line break
// path -- the path on the filesystem to the file this token belongs to
// text -- the full source text of the file
//
// A Tok can be valid or `bad`, a bad token has an end at -1.
//
// A Tok can return its value as a string and print a formatted error message.
//
// A default Tok created with `Tok()` is bad.
// -------------------------------------------------------------------------------------------
value class .Tok(start: Int = 0,
                end: Int = -1,
                lines: Int = 0,
                lineBreak: Int = 0,
                path: String = "",
                text: Chars = Chars[]) {

   // =======================================================================================
	 // Create a new token and an end point. This function is used to
	 // extend the range of a token so that, for example, when parsing
	 // the expression `(+ a b)` its corresponding token goes from the
	 // first brace to the end brace. This will be used to print more
	 // accurate errors.
  static fun createFrom(tok: Tok, end: Int, r: mutable Reader): Tok {
	  Tok(tok.start, end, tok.lines, tok.lineBreak, r.path, r.text)
	}

  static fun createRange(start: Int, end: Int, r: mutable Reader): Tok {
	  Tok(start, end, r.lines, r.lineBreak, r.path, r.text)
	}

  // A bad token should not be used.
  fun isBad(): Bool { this.end == -1 }

  // Return the token as a string, or "BADTOKEN" if bad.
  fun asString(): String {
	  if (this.isBad()) "BADTOKEN" else this.stringFromSlice(this.start, this.end)
	}

  // Print the name of the file, the line number, the last three lines
	// and a carret followed by the error message.
  fun error_message(msg: String): String {
	  if (this.isBad()) return "BADTOKEN";
    (l, lstart, txt, s) = (this.lines, this.start, this.text, "    ");
    s1 = `File ${this.path} at line ${this.lines}`;
    (s2, s3, s4) = (this.lineAt(l-2), this.lineAt(l-1), this.lineAt(l));
    // Print a carret and a message at a particular position in a line
    while (lstart > 0) {
      c = txt[lstart];
      if (this.isLineBreak(c)) {
        !lstart = lstart + 1;
        break void;
      };
      !lstart = lstart - 1;
      !s = s + " ";
    };
    `${s1}\n${s2}\n${s3}\n${s4}\n${s}^--${msg}\n`
  }

  // -------------------------- PRIVATE FUNCTIONS ---------------------------------------------

  // Assuming that our programs are no more than 999 long, this should
  // align each printed line
  fun pad(n: Int): String {  s = if (n < 10) "  " else { if (n < 99) " " else ""}; `${s}${n}`  }

  fun isLineBreak(c: Char): Bool { c == '\n' }

  fun stringFromSlice(start: Int, end: Int): String {
     String::fromChars(this.text.slice(start, end).toArray())
  }

  // Given a line number, print the corresponding line in the file
  // with line number prepended
  fun lineAt(line: Int): String {
    if (line < 0) return "";
    (start, end, lineSeen, txt) = (0, 0, 0, this.text);
    while(end < txt.size()) {
      c = txt[end];
      !end = end + 1;
      if (this.isLineBreak(c)) {
         !lineSeen = lineSeen + 1;
         if (lineSeen == line + 1) break void;
        !start = end;
      };
    };
    s = this.stringFromSlice(start, end - 1);
    `${this.pad(line)}| ${s}`
 }
}



// -------------------------------------------------------------------------------------
// ----------- CHECKING THE AST --------------------------------------------------------
// -------------------------------------------------------------------------------------

value class Name(name: String, tok: Tok, arity: Arity) { }

base class Arity() uses Show {
  children =
    | Exactly(a: Int) // for functions like   (function foo (a b c) 0)     or  (function blub () 0)
    | AtLeast(a: Int) // for functions like   (function bar (x y ...z) 0)  or  (function baz (...args) 0)
    | NotAFunction()  // for variables

  fun canBeCalledWith(argsCnt: Int): Bool {
    this match {
      | Exactly(a) -> argsCnt == a
      | AtLeast(a) -> argsCnt >= a
      | NotAFunction() -> false
    }
  }
  fun toString(): String {
    this match {
      | Exactly(a) -> `${a}`
      | AtLeast(a) -> `${a}+`
      | NotAFunction() -> "<NotAFunction>"
    }
  }
}

mutable class Scope(mutable top: Bool, env: mutable Vector<mutable Names>) {

  static fun create(): mutable Scope {
    mutable Scope(true, mutable Vector<mutable Names>[ mutable Names[] ])
  }

  mutable fun setTop(isTop: Bool): void { this.!top = isTop; }

  readonly fun isTop(): Bool { this.top }

  mutable fun pushScope(): void { this.env.push(mutable Names[]); }

  mutable fun popScope(): void { _ = this.env.pop(); }

  mutable fun define(s: String, t: Tok, arity: Arity): void {
    v = this.env[this.env.size() - 1]; n = Name(s, t, arity);  v.push(n);
  }

  readonly fun isDefined(s: String): Bool { this.hasArity(s).isSome() }

  readonly fun isVariable(s: String): Bool {
    this.hasArity(s) match {
      | Some(NotAFunction()) -> true
      | _ -> false
    }
  }

  readonly fun hasArity(s: String): Option<Arity> {
    this.env.map( v -> v.find( n -> n.name == s ) ) // Vector<Option<Name>>; search in each environment
      .filterNone() // Vector<Name>; keep environments with the name defined
      .maybeGet(0) // Option<Name>
      .map( n -> n.arity ) // Option<Arity>
  }

  readonly fun dbg_print(): void {
     print_string(`Scope:: top=${this.top}`);
     this.env.each(e -> e.each(n -> print_string(`${n.name}(${n.arity})`)));
     print_string("======================");
  }
}

// ===============================================================================================

// -------------- Class Checker ----------------------------------------------------------
// Enforces well-formdness rules. Require all imported files as we
// need their function definitions.
// ----------------------------------------------------------------------------------------
mutable class Checker(env: mutable Scope, r: mutable Reader) {

  // `create` builds a new checker from a reader. Checker are mutable
  // because they update internal state as they walk over the AST.
  static fun create(r: mutable Reader): mutable Checker { mutable Checker(Scope::create(), r) }

  mutable fun fail(tok: Tok, msg: String): void {
    this.r.fail( tok, msg )
  }

  // Add `name` to the environment, fail if already there
  mutable fun checked_add(name: String, t: Tok, arity: Arity): void {
    if (this.env.isDefined(name)) { this.fail(t, `${name} already defined`); }
		else this.env.define(name, t, arity);
  }

  mutable fun addFunction(f: Function): void {
      arity = f.polyArg match {
        | None() -> Exactly(f.params.size())
        | Some(_) -> AtLeast(f.params.size())
      };
      this.checked_add(f.name, f.tok, arity);
  }

  mutable fun addFileToScope( file: File ): void {
    file.funs.each( f -> this.addFunction(f) );
  }

  // Create a new scope with set top, do the checking and then pop the scope
  mutable fun withScope(top: Bool, f: () -> void ): void {
    prevTop = this.env.isTop();
    this.env.setTop(top);

    this.env.pushScope();
    f();
    this.env.popScope();

    this.env.setTop(prevTop);
  }

  /****************************************************************/

  // Check we are at the "top level", basically means we aren't in a nested expression.
  mutable fun check_top_level(n: String, t: Tok): void {
    if (this.env.isTop() == false)  this.fail(t, `${n} can only be used at top-level`);
  }

  // (R8) Init is a reserved name that can't be defined by the user
  mutable fun initAbsent(funs: Vector<Function>): void {
    funs.each(f -> if (f.name == "init") this.fail(f.tok, `Users should not define 'init'`))
  }

  // (R9) Check there is only one `main`
  mutable fun uniqueMain(funs: Vector<Function>, thisFile: File, files: Vector<File>): void {
    funs.find(fn -> fn.name == "main") match {
      | None() -> void;
      | Some(main) -> {
          files.find(fl -> fl.name != thisFile.name && fl.funs.find(fn -> fn.name == "main").isSome()) match {
            | None() -> void;
            | Some(_) -> this.fail(main.tok, `'main' function multiply defined`);
          }
      }
    }
  }

	// ============================================================================
  // Check one file.  We assume `StdLib` is correct, so it is skipped.
	//
  mutable fun file(file: File, fs: Vector<File>): void {
    if (file.name == "StdLib") return void;

    // Check it imports StdLib, add it to scope
    file.imports.find( name -> name == "StdLib" ) match {
      | None() -> return this.fail(file.tok, `Does not import StdLib`);
      | Some(_) -> fs.find( f -> f.name == "StdLib" ) match {
        | Some( stdLib ) -> this.addFileToScope( stdLib )
        | None() -> return this.fail( file.tok, "Path does not include StdLib" )
      }
    };

    // Checking global variables
    // Should we enforce that expressions in global decls do not call
    // functions other than builtins?  It is simpler to initialize all
    // globals without worrying about circular import lists.  By
    // processing decls before functions we naturally do not have
    // those in the environment.  Perhaps we should just have access
    // to basic StdLib functions?
    file.decls.each(d -> this.expression(d) );

    // Check all other imports exist, add them to scope
    file.imports.filter(name -> name != "StdLib" ).each( name -> {
      fs.find( f -> f.name == name ) match {
        | Some( fileToImport ) -> this.addFileToScope( fileToImport )
        | None() -> return this.fail( file.tok, `Path does not include ${name}`)
      }
    } );

    // Checking function definitions
    file.funs.each(f -> this.function(f) );

    // confirm the absence of `init` function in the File for (R8)
    this.initAbsent(file.funs);

    // confirm that if there is a `main` function, it is unique for (R9)
    // TODO can be checked for all files at once
    this.uniqueMain(file.funs, file, fs);
  }

  // Check a function declaration
  mutable fun function(f: Function): void {
	  count = f.params.size();
    arity = f.polyArg match { | None() -> Exactly(count) | Some(_) -> AtLeast(count) };

    this.checked_add(f.name, f.tok, arity);

    this.withScope( true, () -> {
      // add params
      f.params.each(s -> this.checked_add(s, f.tok, NotAFunction()));
      f.polyArg.each(n -> this.checked_add(n, f.tok, NotAFunction()));

      this.expression(f.body);
      this.producesValue(f.name, f.body);
    });
  }

  readonly fun isTopLevelFunction( fName: String ): Bool {
    Array<String>[ "set!", "arr_set!" ].contains( fName );
  }

  // (R7) Check that the function produces a value
  mutable fun producesValue(fName: String, e: Expr): void {
    e match {
      | LitInt(_, _) | LitBool(_, _) | LitChar(_, _) | LitString(_, _) -> void
      | Var(_, _) -> void;
      | Call(t, n, _) -> if ( this.isTopLevelFunction(n) ) this.fail(t, `function '${fName}' does not yield a value.`);
      | Block(_, exprs) -> this.producesValue(fName, exprs[exprs.size() - 1]);
      | Cond(_, _, positive, negative) -> {
        this.producesValue(fName, positive);
        this.producesValue(fName, negative);
      }
      | While(t, _, _) -> this.fail(t, `function '${fName}' does not yield a value.`);
      | Decl(t, _, _) -> this.fail(t, `function '${fName}' does not yield a value.`);
    }
  }

  // Check an expression
  mutable fun expression(e0: Expr): void {
    if (!this.r.ok) return void;

    e0 match {
    | LitInt(_, _) | LitBool(_, _) | LitChar(_, _) | LitString(_, _) -> void
    | Var(t, s) ->{
      if (!this.env.isVariable(s))
        this.fail(t, `${s} is not a variable`);
    }
    | Decl(t, n, e) -> { // check `e` is good; add `n` to environment
      this.check_top_level("let", t);

      // we are not at the top level in `e`
      this.withScope(false, () -> this.expression(e) );

      this.checked_add(n, t, NotAFunction());
    }
    | Call(t, n, es) -> {
      // Check function `n`'s arity matches number of arguments
      // Ensure top level functions are call at top-level
      // Check `es` is good.
      this.env.hasArity(n) match {
        | Some(arity) -> {
            if ( !arity.canBeCalledWith(es.size())) {
              this.fail(t, `function ${n} has ${arity} parameters but got ${es.size()} arguments`)
            };

            if( this.isTopLevelFunction(n) ){
              this.check_top_level(n, t)
            };

            this.withScope( false , () -> es.each(e -> this.expression(e)) );
        };
        | None() -> this.fail(t, `name ${n} not defined`);
      };
    }
    | Block(t, vs) -> { // check that (begin...) is at the top level, and the expressions are good
       this.check_top_level("begin", t);
       this.withScope( true, () -> vs.each(e -> this.expression(e) ) );
    }
    | While(t, e, s) -> { //  check the expression as nested and the statement as top-level
      this.check_top_level("while", t);

      this.withScope( false, () -> this.expression(e) );
      this.withScope( true, () -> this.expression(s) );
    }
    | Cond(t, e, s1, s2) -> { // check the expression as nested and the statements as top-level
      this.check_top_level("if", t);

      this.withScope( false, () -> this.expression(e) );

      this.withScope( true, () -> this.expression(s1) );
      this.withScope( true, () -> this.expression(s2) );
    }
    };
  }
}

module end;
