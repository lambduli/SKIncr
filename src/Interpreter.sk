module Interpreter;

// Aliases for various types, the convection is Xs means Vector of X
// -----------------------------------------------------------------
type Ints = Vector<Int>;
type Bools = Vector<Bool>;
type Strings = Vector<String>;
type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;
type Vals = Vector<Val>;
type Frames = Vector<mutable Frame>;
type Modules = Vector<Module>;
type GlobMap = Map<String, mutable Vals>;  // From module name to module global registers

// ========================= Small bytecode format ==========================================

// A `Module` is a program unit uniquely named by a string, that
// contains a set of private global variables, and a set of public
// functions. The private variables are initialized by calling a
// synthetic `init` function. The initialization code should not call
// functions from other modules (as these may not have been
// initalized).
value class Module(name: String, globs: Int, funs: Funs) {
  fun toString(color: Bool = false): String {
    moduleStr = if (color) {
      "\e[4;31mmodule\e[0m"
    } else {
      "module"
    };

    `${moduleStr} ${this.name}\n\n` +
    this.funs.map( f -> f.toString(color) ).join( "\n" ) +
    "\n"
  }
}

// ==========================================================================================
// A `Fun` is a function that has a globally unique name, a set of
// parameters, a set of local variables, and a body. At this point,
// parameters and locals are a vector of slots, each of which starts
// undefined, and can hold a `Val`. Undefined values should not be
// read by construction.
value class Fun(name: String, params: Int, body: Statements, locals: Int) {
  fun toString(color: Bool = false): String {
    funStr = if (color) {
      "\e[4;31mfunction\e[0m "
    } else {
        "function"
    };

    `${funStr} ${this.name} (${this.params}) [${this.locals}]\n` +
    Code(this.body).toString() +
    "\n"
  }
}

// A `Code` is the body of a function, it has a list of statements. All functions
// must return, so a code block should have at least one statement, ie. `Return`.
value class Code(stmts: Statements) {
 fun toString(): String {
    ln = 0;
    maxlen = (this.stmts.size() - 1).toString().length();
    this.stmts.map( stmt -> {
      line = ln.toString().padLeft(maxlen, ' ');
      !ln = ln + 1;
      line + ": " + stmt.toString()
    }).join( "\n" )
  }
}

// === class Stmt ===========================================================================
base class Stmt {
  children =
	| Store(reg: Int, Expr)
  | GStore(reg: Int, Expr)
  | AStore(reg: Int, idx: Expr, Expr)
  | GAStore(reg: Int, idx: Expr, Expr)
  | CondJump(cond: Int, tgt: Int) // if cond true continue from the next instruction, if false jump
  | Jump(Int) // jump to the instruction at this `offset`
	| Return(Expr) //either a constant or a register (local) or Load, NEVER Invoke

  fun toString(): String {
    this match {
    | Store(r, e) -> `%${r} \u2190 ${e.toString()}`
    | GStore(r, e) -> `@${r} \u2190 ${e.toString()}`
    | AStore(r, i, e) -> `%${r}[${i.toString()}] \u2190 ${e.toString()}`
    | GAStore(r, i, e) -> `@${r}[${i.toString()}] \u2190 ${e.toString()}`
    | CondJump(r, tgt) -> `if %${r} jmp #${tgt}`
    | Jump(tgt) -> `jmp #${tgt}`
    | Return(e) -> `ret ${e.toString()}`
    }
  }
}

// === class Expr ===========================================================================
// Expressions include immediate constants, variable lookup and function call
base class Expr uses Show {
  children =
  | LitI(Int)
  | LitB(Bool)
	| LitS(String)
	| LitC(Char)
  | LitL(Vector<Register>)
  | Closure( fname: String, arity: Int, isVarArg: Bool )
	| Register(r: Int)
  | Invoke(fname: String, args: Ints)
  | IndirectInvoke(r: Int, args: Ints)
  | Load(r: Int)

  fun toString(): String {
    this match {
    | LitI(i) -> `${i}`
    | LitB(b) -> `${b}`
    | LitS(s) -> `"${s}"`
    | LitL(regs) -> "[" + regs.map(r -> r.toString()).join(", ") + "]"
    | LitC(ch) -> `'${ch}'`
    | Closure(fname, arity, isVarArg) -> `<closure:${fname}, arity=${arity}${if (isVarArg) "+" else ""}>`
    | Register(r) -> `%${r}`
    | Load(r) -> `@${r}`
    | Invoke(n, regs) -> `${n}(` + regs.map( r -> `%${r}` ).join(" ") + ")"
    | IndirectInvoke(reg, regs) -> `<indirect:${reg}>(` + regs.map( r -> `%${r}` ).join(" ") + ")"
    }
  }
}


// ===================== Linearize ===================================================

// `Linearize` produces Small bytecode from a flattened AST.

mutable class Linearize(mutable cntr: Int) {

  static fun process( ms: Vector<Reader.Module> ): Vector<Module> {
    lin = Linearize::mcreate();
    ms.map( m -> lin.mod( m ) )
  }

  static fun mcreate(): mutable this {  mutable Linearize(0) }

  mutable fun inc(): void { this.!cntr = this.cntr + 1 }

  mutable fun mod(m: Reader.Module): Module {
    Module(m.name, m.globs, m.funs.map(f -> this.function(f)))
  }

  mutable fun function(f: Reader.Fun): Fun {
    this.!cntr = 0;
    Fun(f.name, f.params, f.body.stmts.map(s -> this.statement(s)).flatten(), f.locals)
  }

  mutable fun expression(e: Reader.Exp): Expr {
    e match {
      | Reader.VInt(i)       -> LitI(i)
      | Reader.VBool(b)      -> LitB(b)
      | Reader.VString(s)    -> LitS(s)
      | Reader.VChar(ch)     -> LitC(ch)
      | Reader.VList(regs)   -> LitL(regs.map( r -> Register(r.id) ))
      | Reader.VClosure(fname, arity, isVarArg) -> Closure(fname, arity, isVarArg)
      | Reader.Register(r)   -> Register(r)
      | Reader.Load(r)       -> Load(r)
      | Reader.Invoke(name, args) -> Invoke(name, args.map(r -> r.id))
      | Reader.IndirectInvoke(reg, args) -> IndirectInvoke(reg.id, args.map(r -> r.id))
    }
  }

  mutable fun statement(s: Reader.Stmt): Statements {
    is = s match {
      | Reader.ArrSet(r, i, e) -> {
        this.inc();
        Statements[AStore(r.id, this.expression(i), this.expression(e))]
      }
      | Reader.GArrSet(r, i, e) -> {
        this.inc();
        Statements[GAStore(r.id, this.expression(i), this.expression(e))]
      }
      | Reader.Set(r, e) -> {
        this.inc();
        Statements[Store(r.id, this.expression(e))]
      }
      | Reader.GSet(r, e) -> {
        this.inc();
        Statements[GStore(r.id, this.expression(e))]
      }
      | Reader.Loop(cnd, Reader.Code(body)) -> {
        topOfLoop = this.cntr;
        this.inc(); // the CondJump instruction is BEFORE all those
        stmts = body.map(s -> this.statement(s)).flatten(); // body of the loop
        this.inc(); // for jump to loop's top
        instrs = mutable Statements[];
        instrs.push(CondJump(cnd.id, this.cntr));
        instrs.extend(stmts);
        instrs.push(Jump(topOfLoop));
        instrs
      }
      | Reader.Branch(cnd, Reader.Code(ifThen), Reader.Code(ifElse)) -> {
        this.inc(); // the CondJump instr is BEFORE both branches
        positive = ifThen.map(s -> this.statement(s)).flatten(); // body of the positive branch
        // at the end of positive branch we need to skip to the end of the negative one
        // so there's gonna be a Jump
        this.inc();
        beforeNegative = this.cntr;
        cond = CondJump(cnd.id, beforeNegative); // skip the positive if the condition is false/zero
        negative = ifElse.map(s -> this.statement(s)).flatten(); // body of the negative branch
        afterNegative = this.cntr;
        skipNegative = Jump(afterNegative);
        instrs = mutable Statements[cond];
        instrs.extend(positive);
        instrs.push(skipNegative);
        instrs.extend(negative);
        instrs
      }
      | Reader.Return(e) -> {
        this.inc();
        Statements[Return(this.expression(e))]
      }
    };
    is.chill()
  }
}

// ==================================================================
// Val represents runtime value, the current types are intergers (I),
// booleans (B), characters (C), strings (S), polymorphic lists (L),
// and null (Null).

// Val.toString() returns a string representation of the constructor.

// Val.toOut() returns a string representation that can be printed.
// ------------------------------------------------------------------
base class Val() uses Show, Equality {
  children =
  | I(Int)
  | B(Bool)
  | C(Char)
  | S(String)
  | L(Vals)
  | A(Vals) // Array
  | Cl(fname: String, arity: Int, isVarArg: Bool ) // Closure of a function
  | Null()

  fun toString(): String {
    this match {
      | I(i) -> `I(${i})`
      | B(b) -> `B(${b})`
      | C(ch) -> `C(${ch})`
      | S(str) -> `S(${str})`
      | L(vals) -> `list(${vals.reduce((s, v) -> `${s}, ${v.toString()}`, "")})`
      | A(vals) -> `array(${vals.reduce((s, v) -> `${s}, ${v.toString()}`, "")})`
      | Cl(fname, arity, isVarArg) -> `<closure:${fname}, argc=${arity}${if(isVarArg)"+" else ""}>`
      | Null() -> `Null`
    }
  }

  fun toOut(): String {
    this match {
      | I(i) -> `${i}`
      | B(b) -> `${b}`
      | C(ch) -> `'${ch}'`
      | L(vals) -> `[${vals.reduce((s, v) -> `${s}, ${v.toOut()}`, "")}]`
      | A(vals) -> `Arr[${vals.reduce((s, v) -> `${s}, ${v.toOut()}`, "")}]`
      | S(str) -> `${str}`
      | Cl(_, _, _) -> `<closure>`
      | Null() -> `NULL`
    }
  }
}

fun zero(): Val { I(0) }

// =======================================================================================
// Frame represents one function's execution state, it has:
//   - globals: a reference to the module's shared array of global registers
//   - locals:  its own private array of locals registers
//   - pc: a program counter indicating what is the next instruction to execute
//   - code: the array of statements to execute
//
// Both locals and globals are fixed sized arrays, modified as new values are computed.
//
// Frame are mutable as we perform updates to the state in place.
// ======================================================================================
mutable class Frame(
				globals: mutable Vals,
				locals: mutable Vals,
				mutable pc: Int,
				code: Statements,
				fname: String) {

  static fun mcreate(
    globals: mutable Vals,
		locals: mutable Vals,
		code: Statements,
		fname: String): mutable Frame
  {
    mutable Frame(globals, locals, 0, code, fname)
  }


  readonly fun toString(): String { `${this.fname} pc=${this.pc}` }
  mutable fun setPC(pc: Int): void { this.!pc = pc; }
	mutable fun incPC(): void { this.!pc = this.pc + 1; }

  // [###] This might fail at runtime
  readonly fun getLocal(r: Int): Val { this.locals[r] }
  // [###] This might fail at runtime
  mutable fun setLocal(r: Int, v: Val): void { this.locals![r] = v; }
  // [###] This might fail at runtime
  readonly fun getGlobal(r: Int): Val { this.globals[r] }
  // [###] This might fail at runtime
  mutable fun setGlobal(r: Int, v: Val): void { this.globals![r] = v; }
  // [###] This might fail at runtime
  readonly fun instruction(): Stmt { this.code[this.pc] }
  // [###] This might fail at runtime
  readonly fun prevInstruction(): Stmt { this.code[this.pc - 1] }
}

// Interpretation exception class
class .InterpreterException(message: String) extends Exception {
  fun getMessage(): String {
    "Interpreter error: " + this.message
  }

  static fun guard<T>( f: () -> T ): Result<T, String> {
    Result::guard( f ) match {
      | Success(val) -> Success(val)
      | Failure(e@InterpreterException(_)) -> Failure(e.getMessage())
      | Failure(e) -> throw e
    }
  }
}

// Example runner
fun runProgram(modules: Modules, io: mutable InterpreterIO = mutable TerminalIO()): Result<Val, String> {
  InterpreterException::guard( () -> {
    eval = Interpreter::mcreate(modules, io);
    eval.call("main", mutable Vals[]);
    eval.run();
  })
}

// ========================= INTERPRETER ================================================
//
// class Interpreter
//   -- modules : all modules in the program
//   -- globals : the globals for each module
//   -- stack   : the stack of active functions invocations
// ======================================================================================
mutable class .Interpreter(
				modules: Modules,
				io: mutable InterpreterIO,
				globals: mutable GlobMap,
				stack: mutable Frames) {

  readonly fun fail<T>(msg: String): T {
    throw InterpreterException(msg + this.toStackTrace() )
  }

  // Creates a fresh interpreter given a set of modules, one of which contains main().
  static fun mcreate(mods: Modules, io: mutable InterpreterIO): mutable this {
    globals = Map::mcreateFromItems(mods.map(m -> (m.name, Vector::mfill(m.globs, zero()))));
    vm = mutable Interpreter(mods, io, globals, mutable Frames[]);
    vm.initialize();
    vm
  }

  // [###] This might fail at runtime
  // errors like some module not having an init or such should not really happen
  // but we call ::run() so it obviously can fail
  mutable fun initialize(): void {
    // We "manually" do what this.call() would do.
    // We can't use it as `init` is not unique function in the whole program.
    this.modules.each(mod -> {
      mod.funs.find(f -> f.name == "init") match {
        | None() -> this.fail( `No 'init' function in module ${mod.name}` ); // this should never happen
        | Some(init) -> {
            globs = this.globals.get(mod.name);
            locals = Vals::mfill(init.locals, Null());
            this.stack.push(Frame::mcreate(globs, locals, init.body, "init"));
            _ = this.run();
            _ = this.stack.pop();
        }
      }
    });
  }

	// Calling function `fname` with arguments `args` causes the interpreter to push a new frame on its stack.
	// The frame has the shared globals and its new locals.
  // [###] This might fail at runtime
  // calling a builtin might result in Failure
  // the initialization part of a normal call should be fine, we expect it to always work
  mutable fun call(fname: String, args: mutable Vals): void {
    if (fname == "builtin_bin") {
      this.callBuiltin2(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.fail(msg)
      }
    } else if (fname == "builtin_un") {
      this.callBuiltin1(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.fail(msg)
      }
    } else if (fname == "builtin_nul") {
      this.callBuiltin0(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.fail(msg)
      }
    } else {
      (func, mod) = this.funAndModFor(fname);
      globs = this.globals.get(mod.name);
      locals = mutable Vals[];
      locals.extend(args);
      rest = Vector::fill(func.locals - func.params, Null());
      locals.extend(rest);
      this.stack.push(Frame::mcreate(globs, locals, func.body, fname))
    }
  }

  mutable fun nativeReturn(val: Val): void {
    fr = Frame::mcreate(mutable Vals[], mutable Vals[val], Statements[Return(Register(0))], "fake");
    this.stack.push(fr);
  }

  // Relies on the uniqueness of function names and that previous
  // passes checked that all called functions are defined.
  readonly fun funAndModFor(fname: String): (Fun, Module) {
    for (m in this.modules) {
		  for (f in m.funs) { if (f.name == fname) return (f, m);	}
		};
		this.fail(`No function named '${fname}'`)
  }

  // Returns the top of call stack.  Relies that stack is never empty
  mutable fun top(): mutable Frame { this.stack[this.stack.size() - 1] }
  mutable fun prev(): mutable Frame { this.stack[this.stack.size() - 2] }

  // [###] This might fail at runtime
  // the `this.call(fname, argVals)` might fail if the expression is a native call
  // also those calls to getLocal and getGlobal might fail
  mutable fun expression(e: Expr): Val {
    e match {
      | LitI(v) -> I(v)
      | LitB(v) -> B(v)
      | LitS(v) -> S(v)
      | LitC(v) -> C(v)
      | LitL(regs) -> L(regs.map(this.expression))
      | Closure(fname, arity, isVarArg) -> Cl(fname, arity, isVarArg)
      | Register(r) -> this.top().getLocal(r)
      | Load(r) -> this.top().getGlobal(r)
      | Invoke(fname, args) -> {
        argVals = Vector::mcreate();
        argVals.extend(args.map(r -> this.top().getLocal(r))); // get the values of the arguments vector
        this.call(fname, argVals); // push a new frame on the stack
        Null() // placeholder value to be overwritten at return
      }
      | IndirectInvoke(r, args) -> {
        closure = this.top().getLocal(r) match {
          | cl@Cl _ -> cl
          | _ -> this.fail( "Calling a non-closure variable" )
        };

        argVals = args.map( r -> this.top().getLocal(r) );

        // Runtime check of correct arity,
        // on vararg function -> move args to a list
        closure match {
          | Cl(_, arity, false) if (argVals.size() == arity) -> void
          | Cl(_, arity, true)  if (argVals.size() >= arity) -> {
            !argVals = Vector[L(argVals)]
          }
          | Cl(fname, _, _) -> {
            this.fail( `Indirectly calling a function "${fname}" with incorrect number of arguments (${argVals.size()})` )
          }
        };

        this.call(closure.fname, argVals.clone());
        Null()
      }
    }
 }

  // run() -----------------------------------------------------------
  // The interpreter's run loop terminates when we return from a stack
  // of size 1 (i.e. from main) The loop has the top of stack and the
  // current frame. It reads the current instruction, decodes and
  // executes it. Then advances the program counter on that frame.
  // Function calls push a new frame so the next time the loop comes
  // around it picks up the new top frame.
  mutable fun run(): Val {
    loop {
      frame = this.top();
      instr = frame.instruction();
      instr match {
        | Store(r, e) -> frame.setLocal(r, this.expression(e))
        | GStore(r, expr) -> frame.setGlobal(r, this.expression(expr))
        | AStore(r, i, expr) -> {
          idx = this.expression(i) match {
            | I(idx) -> idx
            | v -> this.fail( `'arr_set!' call with ${v} as an index` )
          };
          val = this.expression(expr);
          frame.getLocal( r ) match {
            | A(vals) if (idx < vals.size()) -> {
                newArr = vals.clone();
                newArr.set( idx, val );
                frame.setLocal( r, A(newArr.chill()) )
              }
            | A(_) -> this.fail( "'arr_set!' incorrect index" )
            | _ -> this.fail( "'arr_set!' called on a non-array")
          }
        }
        | GAStore(r, i, expr) -> {
          idx = this.expression(i) match {
            | I(idx) -> idx
            | v -> this.fail( `'garr_set!' call with ${v} as an index` )
          };
          val = this.expression(expr);
          frame.getGlobal( r ) match {
            | A(vals) if (idx < vals.size()) -> {
                newArr = vals.clone();
                newArr.set( idx, val );
                frame.setGlobal( r, A(newArr.chill()) )
              }
            | A(_) -> this.fail( "'garr_set!' incorrect index" )
            | _ -> this.fail( "'garr_set!' called on a non-array")
          }
        }
        | CondJump(r, tgt) -> {
            loc = frame.getLocal(r);
            loc match {
              | B(true) -> void
              | B(false) -> { frame.setPC(tgt); continue; }
              | _ -> this.fail(`Value '${loc}' is not a boolean!`)
            }
        }
        | Jump(tgt) -> { frame.setPC(tgt); continue; }
        | Return(expr) -> {
				  if (this.stack.size() == 1)
            return this.expression(expr) // main finished, we're done
					else {
					  prevFrame = this.prev();
						callInstr = prevFrame.prevInstruction();
						retVal = this.expression(expr);
						callInstr match {
						 | Store(r, _) ->  prevFrame.setLocal(r, retVal)
						 | GStore(r, _) -> prevFrame.setGlobal(r, retVal)
						 | bad -> this.fail(`A call was missing a Store or GStore! | ${bad}`)
   				  };
						_ = this.stack.pop();
					}
				}
      };
			frame.incPC();
    };
  }

  readonly fun toStackTrace(): String { this.stack.reduce((trace, fr) -> `${trace}\n${fr.toString()}`, "") }

  mutable fun callBuiltin2(args: readonly Vals): Result<Val, String> {
    (name, a, b) = (args[0].toOut(), args[1], args[2]);
    name match {
      | "<"  ->
			  (a, b) match { | (I(x), I(y)) -> Success(B(x < y))  | _ -> Failure(`(< ${a.toOut()} ${b.toOut()})`) }
      | ">" ->
        (a, b) match { | (I(x), I(y)) -> Success(B(x > y))  | _ -> Failure(`(> ${a.toOut()} ${b.toOut()})`) }
      | "<=" ->
        (a, b) match { | (I(x), I(y)) -> Success(B(x <= y)) | _ -> Failure(`(<= ${a.toOut()} ${b.toOut()})`) }
      | ">=" ->
        (a, b) match { | (I(x), I(y)) -> Success(B(x >= y)) | _ -> Failure(`(>= ${a.toOut()} ${b.toOut()})`) }
      | "+" ->
        (a, b) match { | (I(x), I(y)) -> Success(I(x + y))  | _ -> Failure(`(+ ${a.toOut()} ${b.toOut()})`) }
      | "-" ->
			  (a, b) match { | (I(x), I(y)) -> Success(I(x - y))  | _ -> Failure(`(- ${a.toOut()} ${b.toOut()})`) }
      | "*" ->
        (a, b) match { | (I(x), I(y)) -> Success(I(x * y))  | _ -> Failure(`* ${a.toOut()} ${b.toOut()})`) }
      | "/" ->
			  (a, b) match { | (I(x), I(y)) -> Success(I(x / y))  | _ -> Failure(`(/ ${a.toOut()} ${b.toOut()})`) }
      | "&&" ->
        (a, b) match { | (B(x), B(y)) -> Success(B(x && y)) | _ -> Failure(`(&&  ${a.toOut()} ${b.toOut()})`) }
      | "||" ->
        (a, b) match { | (B(x), B(y)) -> Success(B(x || y)) | _ -> Failure(`(|| ${a.toOut()} ${b.toOut()})`) }
      | "==" ->
        (a, b) match {
          | (I(x), I(y)) -> Success(B(x == y))
          | (C(x), C(y)) -> Success(B(x == y))
          | (S(x), S(y)) -> Success(B(x == y))
          | (B(x), B(y)) -> Success(B(x == y))
          | _ -> Failure(`(== ${a.toOut()} ${b.toOut()})`)
        }
      | "at" ->
          (a, b) match {
            | (L(vals), I(i)) -> if (vals.size() >= i) Success(vals[i]) else Failure(`at: index out of bounds`)
            | (v, i) -> Failure(`at: '${v}' and '${i}' should be a list and a number`)
          }
      | "arr_get" ->
        (a, b) match {
          | (A(vals), I(i)) -> {
            if (i < vals.size()) Success(vals[i])
            else Failure(`'arr_get' called with an incorrect index.`)
          }
          | (v, i) -> Failure(`'arr_get' called on '${v}' and '${i}', expecting an array and a number.`)
        }
      | "write!" -> {
        (a, b) match {
        | (v, L(ls)) -> this.io.write(`${v.toOut()}${ls.reduce((s,e) -> `${s}${e.toOut()}`,"")}`)
        | (v, _) -> this.io.write(`${v.toOut()}`)
        };
        Success(Null())
      }
      | _ -> Failure(`Uknown builtin '${name}'`)
    }
  }

  readonly fun callBuiltin1(args: readonly Vals): Result<Val, String> {
    (name, a) = (args[0].toOut(), args[1]);
    name match {
      | "!" -> a match { | B(b) -> Success(B(! b)) | _ -> Failure(`(! ${a.toOut()})`) }
      | "head" -> a match {
          | L(vals) -> if (vals.size() > 0) Success(vals[0]) else Failure(`head of empty list`)
					| v -> Failure(`head: '${v}' is not a list`)
        }
      | "tail" -> a match {
            | L(vals) -> if (vals.size() > 0) Success(L(vals.slice(1))) else Failure(`tail of empty list`)
            | v -> Failure(`tail: ${v} is not a list`)
          }
      | "size" -> a match { | L(vals) -> Success(I(vals.size())) | v -> Failure(`size: ${v} is not a list`) }
      | "array" -> a match {
          | L(vals) -> Success(A(vals))
          | v -> Failure(`'array' called with '${v}', a non-variadric list of arguments.`)
        }
      | "arr_length" -> a match {
          | A(vals) -> Success(I(vals.size()))
          | v -> Failure(`'arr_length' was called on '${v}'\nwhich is NOT an array.`)
        }
      | _ -> Failure(`Uknown binary-builtin '${name}'`)
    }
  }

  mutable fun callBuiltin0(args: readonly Vals): Result<Val, String> {
    name = args[0].toOut();
    name match {
      | "read!" ->
        this.io.read() match {
          | None() -> Failure(`unable to read!.`)
          | Some(line) ->
            line.toIntOption() match {
						  | None() -> Failure(`read! failed: '${line}' not a number`)
              | Some(i) -> Success(I(i))
            }
      }
      | _ -> Failure(`Uknown builtin '${name}'`)
    }
  }
}


mutable base class .InterpreterIO {
  mutable fun read(): Option<String>;
  mutable fun write(line: String): void;
}

mutable class TerminalIO() extends InterpreterIO {
  readonly fun read() : Option<String> { read_line() }
  readonly fun write(line: String): void{ print_string( line ) }
}

module end;
