module Interpreter;

// Aliases for various types, the convection is Xs means Vector of X
// -----------------------------------------------------------------
type TransferFunctions = Vector<TransferFunction>;
type Ints = Vector<Int>;
type Bools = Vector<Bool>;
type Strings = Vector<String>;
type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;
type Vals = Vector<Val>;
type Frames = Vector<mutable Frame>;
type Modules = Vector<Module>;
type GlobMap = Map<String, mutable Vals>;  // From module name to module global registers

// ==================================================================
// Val represents runtime value, the current types are intergers (I),
// booleans (B), characters (C), strings (S), polymorphic lists (L),
// and null (Null).

// Val.toString() returns a string representation of the constructor.

// Val.toOut() returns a string representation that can be printed.
// ------------------------------------------------------------------
base class Val() uses Show, Equality {
  children =
  | I(Int)
  | B(Bool)
  | C(Char)
  | S(String)
  | L(Vals)
  | Null()

  fun toString(): String {
    this match {
      | I(i) -> `I(${i})`
      | B(b) -> `B(${b})`
      | C(ch) -> `C(${ch})`
      | S(str) -> `S(${str})`
      | L(vals) -> `list(${vals.reduce((s, v) -> `${s}, ${v.toString()}`, "")})`
      | Null() -> `Null`
    }
  }

  fun toOut(): String {
    this match {
      | I(i) -> `${i}`
      | B(b) -> `${b}`
      | C(ch) -> `'${ch}'`
      | L(vals) -> `[${vals.reduce((s, v) -> `${s}, ${v.toOut()}`, "")}]`
      | S(str) -> `${str}`
      | Null() -> `NULL`
    }
  }
}

fun zero(): Val { I(0) }


// ========================= Small bytecode format ==========================================

// A `Module` is a program unit uniquely named by a string, that
// contains a set of private global variables, and a set of public
// functions. The private variables are initialized by calling a
// synthetic `init` function. The initialization code should not call
// functions from other modules (as these may not have been
// initalized).
value class Module(name: String, globs: Int, funs: Funs) {
  fun toString(): String {
       s =  `\e[4;31mmodule\e[0m ${this.name}\n`;
     if (this.funs.size() != 0) this.funs.each(f -> !s =`${s}\n`+ f.toString());
     s + "\n"
  }

  fun toStringUnformatted(): String {
     s = `module ${this.name}\n`;
     if (this.funs.size() != 0) this.funs.each(f -> !s =`${s}\n`+ f.toStringUnformatted());
     s + "\n"
  }
}

// ==========================================================================================
// A `Fun` is a function that has a globally unique name, a set of
// parameters, a set of local variables, and a body. At this point,
// parameters and locals are a vector of slots, each of which starts
// undefined, and can hold a `Val`. Undefined values should not be
// read by construction.
value class Fun(name: String, params: Int, body: Statements, locals: Int) {
  fun toString(): String {
    `\e[4;31mfunction\e[0m ${this.name} (${this.params}) [${this.locals}]` + Code(this.body).toString() + "\n"
  }

  fun toStringUnformatted(): String {
    `function ${this.name} (${this.params}) [${this.locals}]` + Code(this.body).toString() + "\n"
  }
}

// A `Code` is the body of a function, it has a list of statements. All functions
// must return, so a code block should have at least one statement, ie. `Return`.
value class Code(stmts: Statements) {
 fun toString(): String {
    (res, ln, maxlen) = ("", 0, this.stmts.size().toString().length());
    this.stmts.each(s -> {
			lnstr = ln.toString();
      !res = `${res}\n` + lnstr.padLeft(maxlen -lnstr.length(), ' ')	+ `: ` + s.toString();
			!ln = ln + 1
    });
    res
  }
}

// === class Stmt ===========================================================================
base class Stmt {
  children =
	| Store(reg: Int, Expr)
  | GStore(reg: Int, Expr)
  | CondJump(cond: Int, tgt: Int) // if cond true continue from the next instruction, if false jump
  | Jump(Int) // jump to the instruction at this `offset`
	| Return(Expr) //either a constant or a register (local) or Load, NEVER Invoke

  fun toString(): String {
    this match {
    | Store(r, e) -> `%${r} \u2190 ${e.toString()}`
    | GStore(r, e) -> `@${r} \u2190 ${e.toString()}`
    | CondJump(r, tgt) -> `if %${r} jmp #${tgt}`
    | Jump(tgt) -> `jmp #${tgt}`
    | Return(e) -> `ret ${e.toString()}`
    }
  }
}

// === class Expr ===========================================================================
// Expressions include immediate constants, variable lookup and function call
base class Expr uses Show {
  children =
  | LitI(Int)
  | LitB(Bool)
	| LitS(String)
	| LitC(Char)
  | LitL(Vector<Register>)
	| Register(r: Int)
  | Invoke(fname: String, args: Ints)
  | Load(r: Int)

  fun toString(): String {
    this match {
    | LitI(i) -> `${i}`
    | LitB(b) -> `${b}`
    | LitS(s) -> `"${s}"`
    | LitL(regs) -> "[" + regs.map(r -> r.toString()).join(", ") + "]"
    | LitC(ch) -> `'${ch}'`
    | Register(r) -> `%${r}`
    | Load(r) -> `@${r}`
    | Invoke(n, regs) -> `${n}(` + regs.map( r -> `%${r}` ).join(" ") + ")"
    }
  }
}

// =========================================================================================

// Return a register/load built by stripping off the string's prefix
fun strToReg(r: String) : Register { Register(r.stripPrefix("%").toInt()) }
fun strToLoad(r: String) : Load { Load(r.stripPrefix("%").toInt()) }

// ===================== Linearize ===================================================

// `Linearize` produces Small bytecode from a flattened AST.

mutable class Linearize(mutable cntr: Int) {

  static fun mcreate(): mutable this {  mutable Linearize(0) }

  mutable fun inc(): void { this.!cntr = this.cntr + 1 }

 mutable fun mod(m: Reader.Module): Module {
    Module(m.name, m.globs, m.funs.map(f -> this.function(f)))
  }

  mutable fun function(f: Reader.Fun): Fun {
    this.!cntr = 0;
    Fun(f.name, f.params, f.body.stmts.map(s -> this.statement(s)).flatten(), f.locals)
  }

  mutable fun expression(e: Reader.Exp): Expr {
    e match {
      | Reader.VInt(i)       -> LitI(i)
      | Reader.VBool(b)      -> LitB(b)
      | Reader.VString(s)    -> LitS(s)
      | Reader.VChar(ch)     -> LitC(ch)
      | Reader.VList(regs)   -> LitL(regs.map(this.expToReg))
      | Reader.Register(str) -> strToReg(str)
      | Reader.Load(str)     -> strToLoad(str)
      | Reader.Invoke(name, args) -> Invoke(name, args.map(r -> strToReg(r.name).r))
    }
  }

  // Reader.Exp for the condition in a  WHILE is a Register or return -1
  mutable fun expToReg(e: Reader.Exp): Register {
    e match { | Reader.Register(s) -> strToReg(s) | _ -> Register(-1) }
  }

  mutable fun statement(s: Reader.Stmt): Statements {
    is = s match {
      | Reader.Set(r, e) -> { this.inc(); Statements[Store(this.expToReg(r).r, this.expression(e))] }
      | Reader.GSet(r, e) -> { this.inc(); Statements[GStore(this.expToReg(r).r, this.expression(e))] }
      | Reader.Loop(cnd, Reader.Code(body)) -> {
        cexpr = this.expToReg(cnd);
        topOfLoop = this.cntr;
        this.inc(); // the CondJump instruction is BEFORE all those
        stmts = body.map(s -> this.statement(s)).flatten(); // body of the loop
        this.inc(); // for jump to loop's top
        instrs = mutable Statements[];
        instrs.push(CondJump(cexpr.r, this.cntr));
        instrs.extend(stmts);
        instrs.push(Jump(topOfLoop));
        instrs
      }
      | Reader.Branch(cnd, Reader.Code(ifThen), Reader.Code(ifElse)) -> {
        cExpr = this.expToReg(cnd); // cndExpr has to be a Register
        this.inc(); // the CondJump instr is BEFORE both branches
        positive = ifThen.map(s -> this.statement(s)).flatten(); // body of the positive branch
        // at the end of positive branch we need to skip to the end of the negative one
        // so there's gonna be a Jump
        this.inc();
        beforeNegative = this.cntr;
        cond = CondJump(cExpr.r, beforeNegative); // skip the positive if the condition is false/zero
        negative = ifElse.map(s -> this.statement(s)).flatten(); // body of the negative branch
        afterNegative = this.cntr;
        skipNegative = Jump(afterNegative);
        instrs = (mutable Vector<Stmt>[cond]);
        instrs.extend(positive);
        instrs.push(skipNegative);
        instrs.extend(negative);
        instrs
      }
      | Reader.Return(e) -> { this.inc(); Vector<Stmt>[Return(this.expression(e))] }
    };
    is.chill()
  }
}
// =================================================================================

// ANALYIS ANALYIS ANALYIS ANALYIS ANALYIS ANALYIS ANALYIS ANALYIS ANALYIS ANALYIS ANALYIS

// === class State =================================================================
// The State of a RD analysis contains two vectors of RD (reaching definitions)
// for each label in the program. These vectors contain on bitvec per variable.
// Thus the size of the state is 2 x |label| x |variables| x |label| (give or take)
// By design, State is an immutable class, every change creates a copy.
// Variables and labels are modelled by integers starting at 0.
// =================================================================================
value class State(entry: Vector<RD>, exit: Vector<RD>) {
  // creates a State given the number of labels and variables.
  static fun create(vars: Int, labels: Int): State {
		(entries, exits, i) = (mutable Vector[], mutable Vector[], 0);
		while (i < labels) {
			 entries.push(RD::create(vars, labels));
 			 exits.push(RD::create(vars, labels));
			 !i = i+1;
		};
		State(entries.chill(), exits.chill())
  }

  // get the RD of the entry node for label i
  fun entryAt(i: Int): RD { this.entry[i] }

  // get the RD of the exit node for label i
  fun exitAt(i: Int): RD { this.exit[i] }

  // internal cuisine: copy this State but with RD d set at label,
	// if entry is true, this done for the entry otherwise the exit.
  fun copyWith(entry: Bool, label: Int, d: RD): State {
		(entries, exits, i) = (mutable Vector[], mutable Vector[], 0);
		while (i < this.entry.size()) {
		   eElem = if (entry && i == label) { d } else { this.entry[i] };
			 entries.push(eElem);
		   xElem = if (!entry && i == label) d else this.exit[i];
			 exits.push(xElem);
			 !i = i+1;
		};
		State(entries.chill(), exits.chill())
  }

  // toString the entry/exit node at label
  fun toStringAt(entry: Bool, label: Int): String {
     rd = if (entry) this.entry[label] else this.exit[label];
		 rd.toString()
	}

  // toString this state, the function f is provided so we can
	// print the instructions together with their entry/exit, it
	// makes things more readable
  fun toString(f: Fun): String {
	  (s, i) =  ("", 0);
		while (i < this.entry.size()) {
		   is = f.body[i].toString();
		   !s = `${s}${this.toStringAt(true, i)}\n${i} ${is}\n${this.toStringAt(false, i)}\n\n`;
			 !i = i+1;
    };
    s
  }
}

// class BitVec ==========================================================================
// A BitVec is an immutable class that starts with all bits set to
// false, a bit can be set and unset, a bitvec can include
// another if all the bits set in the other are also set in this, two
// bitvecs can be joined to yield a new bitvec that has the union of
// bits sets.
// ======================================================================================
value class BitVec(bits: Bools) {
 // create a bitvec of card bits, set to false
 static fun create(card: Int): BitVec {
		(i, vec) = (0, mutable Vector[]);
		while(i < card) { vec.push(false); !i=i+1 };
		BitVec(vec.chill())
	}

  // set bit pos to true
  fun set(pos: Int): BitVec { this.setTo(pos, true) }
	// set bit pos to false
  fun unset(pos: Int): BitVec { this.setTo(pos, false) }

  // internal cuisine: copies and sets the right bit to val
  fun setTo(pos: Int, val: Bool): BitVec {
		(i, vec) = (0, mutable Vector[]);
		while(i < this.bits.size()) {
		  if (i == pos) { vec.push(val) } else { vec.push(this.bits[i]) };
			!i=i+1
		};
		BitVec(vec.chill())
	}

  // || or two bit vectors
  fun join(other: BitVec): BitVec {
		(i, vec) = (0, mutable Vector[]);
		while(i < this.bits.size()) { vec.push(this.bits[i] || other.bits[i]); !i=i+1	};
		BitVec(vec.chill())
	}

  // returns true if every bit set in other is set in this
	fun includes(other: BitVec): Bool {
		(i, res) = (0, true);
		while(res && i < this.bits.size()) { if (other.bits[i]) !res = res && this.bits[i]; !i=i+1	};
		res
	}

  // returns the value of bit pos
  fun isSet(pos: Int): Bool { this.bits[pos] }

  // how many bits do we have?
  fun size(): Int { this.bits.size() }

  // how many bits are set to true?
  fun count(): Int {
	  (i, res) = (0, 0);
		while (i < this.size()) { if (this.bits[i]) !res = res+1;	!i = i+1 };
    res
  }

  // string representation, e.g. [1001110]
  fun toString(): String {
	  (s, i) = ("[", 0);
		while (i < this.bits.size()) { !s = s + if (this.bits[i]) "1" else "0"; !i = i+1 };
	  s+"]"
	}
}
// ==========================================================================================


// === class RD ==============================================================================
// RD tracks the reaching definitions of variables. In the context of
// our language, each local variable is identified by a positive
// integer, and each definition is identified by a label, a positive
// integer as well. Labels correspond to statements in the program.
// ==========================================================================================
value class RD(vars: Vector<BitVec>) {

  // creates an empty RD object for varCard variables and labelCard labels
  static fun create(varCard: Int, labelCard: Int): RD {
		(i, vec) = (0, mutable Vector[]);
		while(i < varCard) { vec.push(BitVec::create(labelCard)); !i=i+1 };
		RD(vec.chill())
  }

  // set var at label to true, returns a new RD
  fun set(var: Int, label: Int): RD {
		(i, vec) = (0, mutable Vector[]);
		while(i < this.vars.size()) {
		  if (i == var) { vec.push(this.vars[i].set(label)) } else { vec.push(this.vars[i])	};
			!i=i+1
		};
		RD(vec.chill())
	}

  // is var at label true?
  fun isSet(var: Int, label: Int): Bool { this.vars[var].isSet(label) }

  // clears all the bits for var
  fun clear(var: Int): RD {
		(i, vec, vars) = (0, mutable Vector[], this.vars);
		while(i < vars.size()) {
      if (i == var) { vec.push(BitVec::create(vars[i].size())) } else { vec.push(vars[i])	};
			!i=i+1
		};
		RD(vec.chill())
	}

  // the union of two RD objects: for each var we || the bitvecs
  fun join(other: RD): RD {
    (i, vec) = (0, mutable Vector[]);
    while(i < this.vars.size()) { vec.push(this.vars[i].join(other.vars[i])); !i=i+1 };
		RD(vec.chill())
  }

  // is other included in this? I.e. for every var are the bitvecs included
  fun includes(other: RD): Bool {
		(i, res) = (0, true);
		while(res && i < this.vars.size()) { !res = res && this.vars[i].includes(other.vars[i]); !i=i+1 };
		res
	}

  // string representation, eg. "1<-[3,4] 2<-[0,2,12]", variable with empty bitvecs are omitted
  fun toString(): String {
	   (s, i) = ("", 0);
		 while (i < this.vars.size()) {
		   v = this.vars[i];
			 if (v.count() > 0) {
			   (!s, j) = (`${s}${i}<-[`, 0);
				 while (j < v.size()) {
				   if (v.isSet(j)) !s = `${s}${j}, `;
					 !j = j+1
				  };
					!s = s.stripSuffix(", ") + "] ";
 			 };
		   !i = i+1;
		 };
		 s
	}
}

// === class TransferFunction =============================================================
// Abstract class that defines the eval() function to take a state and return a new
// state as well as a bool to tell if there was a change.
// ========================================================================================
base class TransferFunction() {
  fun eval(s: State): (Bool, State);
}

// === Edge ==============================================================================
// An edge in the control flow graph tranfer information from the exit
// of a node to the entry of another node. The new information is
// joined with the existing contents.
// =======================================================================================
class Edge(from: Int, to: Int) extends TransferFunction {
  // As an optimization, if the entry already has all the information
  // contained in exit, we do nothing.
  fun eval(s: State): (Bool, State) {
	  (exit, entry) = (s.exitAt(this.from), s.entryAt(this.to));
		if (entry.includes(exit)) { (false, s) } else { (true, s.copyWith(true, this.to, entry.join(exit))) }
	}
}

// === class Identity ====================================================================
// An node that does not change the state only propagates it.
// =======================================================================================
class Identity(label: Int) extends TransferFunction {
  fun eval(s: State): (Bool, State) {
	  (exit, entry) = (s.exitAt(this.label), s.entryAt(this.label));
		if (exit.includes(entry)) { (false, s) } else { (true, s.copyWith(false, this.label, exit.join(entry))) }
	}
}

// == class Store ========================================================================
// Store into a local variable. This kills all definitions for that variable and adds the
// new one.
// ======================================================================================
class Def(label: Int, reg: Int) extends TransferFunction {
  fun eval(s: State): (Bool, State)  {
	  (exit, entry) = (s.exitAt(this.label), s.entryAt(this.label));
		!entry = entry.clear(this.reg).set(this.reg, this.label);
		if (exit.includes(entry)) { (false, s) } else { (true, s.copyWith(false, this.label, exit.join(entry))) }
	}
}


// analyze all modules, i.e. files, ignoring the StdLib as it is only wrappers
fun analyzeAll(modules: Modules): void { modules.each(m -> if (m.name != "StdLib") analyzeModule(m)) }

// For now only analyze the main function
fun analyzeModule(m: Module) : void { m.funs.each(f -> if (f.name == "main") analyzeFun(f)) }

// Ok, here is where do the work: initialize the state, fixpoint, and print the resulting state
fun analyzeFun(f: Fun): void {
	print_string(`Analyzing function ${f.name} with ${f.params} parameters and ${f.locals} locals`);
  state = fixpoint(initFunctions(f), State::create(f.locals, f.body.size()));
	print_string(state.toString(f));
}

// This selects transfer functions following the code of the program
fun initFunctions(f: Fun): TransferFunctions {
	(funs, i) = (mutable TransferFunctions[], 0);
	while (i < f.body.size()) {
	  f.body[i] match {
    | Store(reg, _) -> { funs.push(Def(i, reg)); funs.push(Edge(i, i+1))	}
    | GStore(_, _) -> { funs.push(Identity(i)); funs.push(Edge(i, i+1))	}
    | CondJump(_, tgt) -> { funs.push(Identity(i)); funs.push(Edge(i, i+1)); funs.push(Edge(i, tgt)) }
    | Jump(tgt) -> { funs.push(Identity(i)); funs.push(Edge(i, tgt)) }
    | Return(_) -> funs.push(Identity(i))
		};
    !i = i+1;
  };
  funs.chill();
}

// precompute the visit order of transfer functions, not that there are more functions
// than labels because we also put edges into this set
fun indexes(functions: TransferFunctions): Ints {
   (vec, i, len) = (mutable Vector[], 0, functions.size());
	 while (i < len) { vec.push(i); !i = i+1 };
	 if (true) vec.chill() else permute(vec)
}

// a random permutation of the visit order
fun permute(vec: mutable Ints): Ints {
  (i, len, rnd) = (0, (vec.size()/2).toInt(), Random::mcreate(42)); // FIXSKIP: crashes when now().toInt()));
	while (i < len) {
	  (r1, r2) = (rnd.random(0, vec.size()), rnd.random(0, vec.size()));
		(a, b, !i) = (vec[r1], vec[r2], i+1);
		vec.set(r2, a); vec.set(r1, b);
	};
	vec.chill()
}

// this is the heart of the algorithm, we keep on visiting until we have observed
// no canges to the state at the end of one iteration.
// Prints how many transfer functions where invoked.
fun fixpoint(functions: TransferFunctions, state: State): State {
	(current, steps) = (state, 0);
  loop {
	   (i, change, indexes) = (0, false, indexes(functions));
		 while (i < indexes.size()) {
			 (update, !current) = functions[indexes[i]].eval(current);
       (!change, !i, !steps) = (change || update, i+1, steps+1);
     };
		 print_string("steps so far "+steps);
     if (!change) return current;
  };
}

/*
fun fixpoint2(functions: TransferFunctions, state: State): State {
  (work, currrent, step) = (mutable Ints[], state, 0);
  work.push(0);
	while (work.size() > 0) {
	   !step = step + 1;
     i = work.pop();
		 (update, !current) = functions[i].eval(current);
		 if (update) {
		    thisNode node = functions[i] match {
			   | Edge(_, to) -> to
				 | Identity(l) -> l
				 | Def(l) -> l
  			 };
				 functions.each(f -> {
            f match {
    			   | Edge(from,_) ->  if (from = thisNode) work.push(j);
		    		 | Identity(l) ->
				     | Def(l) -> l

            };

         });
        // what is the current label
				// find all successor transfer functions
     }
  }
  print_string("steps so far "+steps);
  current
}
*/

// =======================================================================================
// Frame represents one function's execution state, it has:
//   - globals: a reference to the module's shared array of global registers
//   - locals:  its own private array of locals registers
//   - pc: a program counter indicating what is the next instruction to execute
//   - code: the array of statements to execute
//
// Both locals and globals are fixed sized arrays, modified as new values are computed.
//
// Frame are mutable as we perform updates to the state in place.
// ======================================================================================
mutable class Frame(
				globals: mutable Vals,
				locals: mutable Vals,
				mutable pc: Int,
				code: Statements,
				fname: String) {

  static fun mcreate(
    globals: mutable Vals,
		locals: mutable Vals,
		code: Statements,
		fname: String): mutable Frame
  {
    mutable Frame(globals, locals, 0, code, fname)
  }


  readonly fun toString(): String { `${this.fname} pc=${this.pc}` }
  mutable fun setPC(pc: Int): void { this.!pc = pc; }
	mutable fun incPC(): void { this.!pc = this.pc + 1; }

  // [###] This might fail at runtime
  readonly fun getLocal(r: Int): Val { this.locals[r] }
  // [###] This might fail at runtime
  mutable fun setLocal(r: Int, v: Val): void { this.locals![r] = v; }
  // [###] This might fail at runtime
  readonly fun getGlobal(r: Int): Val { this.globals[r] }
  // [###] This might fail at runtime
  mutable fun setGlobal(r: Int, v: Val): void { this.globals![r] = v; }
  // [###] This might fail at runtime
  readonly fun instruction(): Stmt { this.code[this.pc] }
  // [###] This might fail at runtime
  readonly fun prevInstruction(): Stmt { this.code[this.pc - 1] }
}

// Example runner
fun runProgram(modules: Modules, io: mutable InterpreterIO = mutable TerminalIO()): Result<Val, String> {
  eval = Interpreter::mcreate(modules, io);
	eval.call("main", mutable Vals[]);
	eval.run();
}

// ========================= INTERPRETER ================================================
//
// class Interpreter
//   -- modules : all modules in the program
//   -- globals : the globals for each module
//   -- stack   : the stack of active functions invocations
// ======================================================================================
mutable class .Interpreter(
				modules: Modules,
				io: mutable InterpreterIO,
				globals: mutable GlobMap,
				stack: mutable Frames,
				mutable failure: (Bool, String)) {

  mutable fun fail(msg: String): void { this.!failure = (false, `Error: ${msg}`) }
  readonly fun ok(): Bool { this.failure.i0 }
  readonly fun why(): String { this.failure.i1 }

  // Creates a fresh interpreter given a set of modules, one of which contains main().
  static fun mcreate(mods: Modules, io: mutable InterpreterIO): mutable this {
    globals = Map::mcreateFromItems(mods.map(m -> (m.name, Vector::mfill(m.globs, zero()))));
    vm = mutable Interpreter(mods, io, globals, mutable Frames[], (true, "default: no error"));
    vm.initialize();
    vm
  }

  // [###] This might fail at runtime
  // errors like some module not having an init or such should not really happen
  // but we call ::run() so it obviously can fail
  mutable fun initialize(): void {
    // We "manually" do what this.call() would do.
    // We can't use it as `init` is not unique function in the whole program.
    this.modules.each(mod -> {
      mod.funs.find(f -> f.name == "init") match {
        | None() -> void; // this should never happen
        | Some(init) -> {
            globs = this.globals.get(mod.name);
            locals = Vals::mfill(init.locals, Null());
            this.stack.push(Frame::mcreate(globs, locals, init.body, "init"));
            _ = this.run();
            _ = this.stack.pop();
        }
      }
    });
  }

	// Calling function `fname` with arguments `args` causes the interpreter to push a new frame on its stack.
	// The frame has the shared globals and its new locals.
  // [###] This might fail at runtime
  // calling a builtin might result in Failure
  // the initialization part of a normal call should be fine, we expect it to always work
  mutable fun call(fname: String, args: mutable Vals): void {
    if (fname == "builtin_bin") {
      this.callBuiltin2(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.fail(msg)
      }
    } else if (fname == "builtin_un") {
      this.callBuiltin1(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.fail(msg)
      }
    } else if (fname == "builtin_nul") {
      this.callBuiltin0(args) match {
        | Success(val) -> this.nativeReturn(val)
        | Failure(msg) -> this.fail(msg)
      }
    } else {
      func = this.functionFor(fname);
      globs = this.globalsFor(fname);
      locals = mutable Vals[];
      locals.extend(args);
      rest = Vector::fill(func.locals - func.params, Null());
      locals.extend(rest);
      this.stack.push(Frame::mcreate(globs, locals, func.body, fname))
    }
  }

  mutable fun nativeReturn(val: Val): void {
    fr = Frame::mcreate(mutable Vals[], mutable Vals[val], Statements[Return(Register(0))], "fake");
    this.stack.push(fr);
  }

	// Relies on the uniqueness of function names.
  mutable fun globalsFor(fname: String): mutable Vals { this.globals.get(this.moduleFor(fname).name) }

  // Relies on the uniqueness of function names.
  readonly fun functionFor(fname: String): Fun { this.funAndModFor(fname).i0 }

  // Relies on the uniqueness of function names.
  readonly fun moduleFor(fname: String): Module { this.funAndModFor(fname).i1	}

  // Relies on the uniqueness of function names and that previous
  // passes checked that all called functions are defined.
  readonly fun funAndModFor(fname: String): (Fun, Module) {
    for (m in this.modules) {
		  for (f in m.funs) { if (f.name == fname) return (f, m);	}
		};
		invariant_violation(`No function named '${fname}'.`)
  }

  // Returns the top of call stack.  Relies that stack is never empty
  mutable fun top(): mutable Frame { this.stack[this.stack.size() - 1] }
  mutable fun prev(): mutable Frame { this.stack[this.stack.size() - 2] }

  // [###] This might fail at runtime
  // the `this.call(fname, argVals)` might fail if the expression is a native call
  // also those calls to getLocal and getGlobal might fail
  mutable fun expression(e: Expr): Val {
    e match {
      | LitI(v) -> I(v)
      | LitB(v) -> B(v)
      | LitS(v) -> S(v)
      | LitC(v) -> C(v)
      | LitL(regs) -> L(regs.map(this.expression))
      | Register(r) -> this.top().getLocal(r)
      | Load(r) -> this.top().getGlobal(r)
      | Invoke(fname, args) -> {
        argVals = Vector::mcreate();
        argVals.extend(args.map(r -> this.top().getLocal(r))); // get the values of the arguments vector
        this.call(fname, argVals); // push a new frame on the stack
        Null() // placeholder value to be overwritten at return
      }
    }
 }

  // [###] This might fail at runtime
  // this would be a type error, I think
  mutable fun toBool(v: Val): Result<Bool, String> {
	 v match { | B(b) -> Success(b) | _ -> Failure(`Value '${v}' is not a boolean!`) }
	}

  // run() -----------------------------------------------------------
  // The interpreter's run loop terminates when we return from a stack
  // of size 1 (i.e. from main) The loop has the top of stack and the
  // current frame. It reads the current instruction, decodes and
  // executes it. Then advances the program counter on that frame.
  // Function calls push a new frame so the next time the loop comes
  // around it picks up the new top frame.
  mutable fun run(): Result<Val, String> {
    loop {
      frame = this.top();
      instr = frame.instruction();
      if (!this.ok()) return Failure(this.why());
      instr match {
        | Store(r, e) -> frame.setLocal(r, this.expression(e))
        | GStore(r, expr) -> frame.setGlobal(r, this.expression(expr))
        | CondJump(r, tgt) -> {
            loc = frame.getLocal(r);
            this.toBool(loc) match {
              | Success(true) -> void
              | Success(false) -> { frame.setPC(tgt); continue; }
              | Failure(m) -> return Failure(m)
            }
        }
        | Jump(tgt) -> { frame.setPC(tgt); continue; }
        | Return(expr) -> {
				  if (this.stack.size() == 1)
            return Success(this.expression(expr)) // main finished, we're done
					else {
					  prevFrame = this.prev();
						callInstr = prevFrame.prevInstruction();
						retVal = this.expression(expr);
						callInstr match {
						 | Store(r, _) ->  prevFrame.setLocal(r, retVal)
						 | GStore(r, _) -> prevFrame.setGlobal(r, retVal)
						 | bad -> return Failure(`A call was missing a Store or GStore! | ${bad}`)
   				  };
						_ = this.stack.pop();
					}
				}
      };
			frame.incPC();
    };
  }

  readonly fun toStackTrace(): String { this.stack.reduce((trace, fr) -> `${trace}\n${fr.toString()}`, "") }

  mutable fun callBuiltin2(args: readonly Vals): Result<Val, String> {
    (name, a, b) = (args[0].toOut(), args[1], args[2]);
    name match {
      | "<"  ->
			  (a, b) match { | (I(x), I(y)) -> Success(B(x < y))  | _ -> Failure(`(< ${a.toOut()} ${b.toOut()})`) }
      | ">" ->
        (a, b) match { | (I(x), I(y)) -> Success(B(x > y))  | _ -> Failure(`(> ${a.toOut()} ${b.toOut()})`) }
      | "<=" ->
        (a, b) match { | (I(x), I(y)) -> Success(B(x <= y)) | _ -> Failure(`(<= ${a.toOut()} ${b.toOut()})`) }
      | ">=" ->
        (a, b) match { | (I(x), I(y)) -> Success(B(x >= y)) | _ -> Failure(`(>= ${a.toOut()} ${b.toOut()})`) }
      | "+" ->
        (a, b) match { | (I(x), I(y)) -> Success(I(x + y))  | _ -> Failure(`(+ ${a.toOut()} ${b.toOut()})`) }
      | "-" ->
			  (a, b) match { | (I(x), I(y)) -> Success(I(x - y))  | _ -> Failure(`(- ${a.toOut()} ${b.toOut()})`) }
      | "*" ->
        (a, b) match { | (I(x), I(y)) -> Success(I(x * y))  | _ -> Failure(`* ${a.toOut()} ${b.toOut()})`) }
      | "/" ->
			  (a, b) match { | (I(x), I(y)) -> Success(I(x / y))  | _ -> Failure(`(/ ${a.toOut()} ${b.toOut()})`) }
      | "&&" ->
        (a, b) match { | (B(x), B(y)) -> Success(B(x && y)) | _ -> Failure(`(&&  ${a.toOut()} ${b.toOut()})`) }
      | "||" ->
        (a, b) match { | (B(x), B(y)) -> Success(B(x || y)) | _ -> Failure(`(|| ${a.toOut()} ${b.toOut()})`) }
      | "==" ->
        (a, b) match {
          | (I(x), I(y)) -> Success(B(x == y))
          | (C(x), C(y)) -> Success(B(x == y))
          | (S(x), S(y)) -> Success(B(x == y))
          | (B(x), B(y)) -> Success(B(x == y))
          | _ -> Failure(`(== ${a.toOut()} ${b.toOut()})`)
        }
      | "at" ->
          (a, b) match {
            | (L(vals), I(i)) -> if (vals.size() >= i) Success(vals[i]) else Failure(`at: index out of bounds`)
            | (v, i) -> Failure(`at: '${v}' and '${i}' should be a list and a number`)
          }
      | "write!" -> {
        (a, b) match {
        | (v, L(ls)) -> this.io.write(`${v.toOut()}${ls.reduce((s,e) -> `${s}${e.toOut()}`,"")}`)
        | (v, _) -> this.io.write(`${v.toOut()}`)
        };
        Success(Null())
      }
      | _ -> Failure(`Uknown builtin '${name}'`)
    }
  }

  readonly fun callBuiltin1(args: readonly Vals): Result<Val, String> {
    (name, a) = (args[0].toOut(), args[1]);
    name match {
      | "!" -> a match { | B(b) -> Success(B(! b)) | _ -> Failure(`(! ${a.toOut()})`) }
      | "head" -> a match {
          | L(vals) -> if (vals.size() > 0) Success(vals[0]) else Failure(`head of empty list`)
					| v -> Failure(`head: '${v}' is not a list`)
        }
      | "tail" -> a match {
            | L(vals) -> if (vals.size() > 0) Success(L(vals.slice(1))) else Failure(`tail of empty list`)
            | v -> Failure(`tail: ${v} is not a list`)
          }
      | "size" -> a match { | L(vals) -> Success(I(vals.size())) | v -> Failure(`size: ${v} is not a list`) }
      | _ -> Failure(`Uknown binary-builtin '${name}'`)
    }
  }

  mutable fun callBuiltin0(args: readonly Vals): Result<Val, String> {
    name = args[0].toOut();
    name match {
      | "read!" ->
        this.io.read() match {
          | None() -> Failure(`unable to read!.`)
          | Some(line) ->
            line.toIntOption() match {
						  | None() -> Failure(`read! failed: '${line}' not a number`)
              | Some(i) -> Success(I(i))
            }
      }
      | _ -> Failure(`Uknown builtin '${name}'`)
    }
  }
}


mutable base class .InterpreterIO {
  mutable fun read(): Option<String>;
  mutable fun write(line: String): void;
}

mutable class TerminalIO() extends InterpreterIO {
  readonly fun read() : Option<String> { read_line() }
  readonly fun write(line: String): void{ print_string( line ) }
}

module end;
