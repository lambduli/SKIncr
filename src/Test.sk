module Test;

// A name of the test and optional error message
value class TestCase(name: String, message: Option<String>){}

// Result of complete run
base class TestResult(){
  children =
  | Successful( Interpreter.Val )
  | ReaderError( String )
  | ExecutionError( String )

  // Assert that result equals to a expected value
  fun assert_val( name: String, expectedValue: Interpreter.Val ): TestCase {
    msg = this match {
      | Successful(val) if (val == expectedValue) -> {
        None()
      }
      | Successful(val) -> {
        Some( `Expected result ${expectedValue}, got ${val}` )
      }
      | ReaderError(msg) -> {
        Some( `Reader failed with message: ${msg}` )
      }
      | ExecutionError(msg) -> {
        Some( `Execution failed with message: ${msg}` )
      }
    };
    TestCase(name, msg)
  }

  fun assert_no_fail( name: String ): TestCase {
    msg = this match {
      | Successful(_) -> {
        None()
      }
      | ReaderError(msg) -> {
        Some( `Reader failed with message: ${msg}` )
      }
      | ExecutionError(msg) -> {
        Some( `Execution failed with message: ${msg}` )
      }
    };
    TestCase(name, msg)
  }

  // Assert that execution failed in runtime
  fun assert_execution_fail( name: String ): TestCase {
    msg = this match {
      | Successful(val) -> {
        Some( `Expected execution failure, got ${val}` )
      }
      | ReaderError(msg) -> {
        Some( `Reader failed with message: ${msg}` )
      }
      | ExecutionError(_) -> {
        None()
      }
    };
    TestCase(name, msg)
  }
}

// A class for collecting TestCases
mutable class TestHarness( tests: mutable Vector<TestCase> ){

  static fun mcreate() : mutable this {
    mutable TestHarness( mutable Vector<TestCase>[] )
  }

  mutable fun pushTestCase( case: TestCase ): void {
    this.tests.push( case )
  }

  // Report all failed tests and the count of all, failed and succesful tests
  readonly fun report(): String {
    allCnt = this.tests.size();
    successfulCnt = this.tests.filter( test -> test.message.isNone() ).size();
    errs: Vector<String> = this.tests.map( test -> test.message match {
      | Some( msg ) -> Some( `    ${test.name}: ${msg}`  )
      | None() -> None()
    }).filterNone();
    unsuccessfulCnt = errs.size();

    err = if ( unsuccessfulCnt != 0 ){
      "Errors:\n" +
      "\n".join( errs ) +
      "\n\n"
    } else {
      ""
    };

    err +
    `Total tests: ${allCnt}\n` +
    `Failed tests: ${unsuccessfulCnt}\n` +
    `Passing tests: ${successfulCnt}\n`
  }
}

// A file-based test that creates a file (snapshot) that captures the expected output,
// or if it already exists, validates that the current output matches the expected one
class SnapshotTest( snapshotName: String, inputsFolder: String, outputsFolder: String, log: Bool ){
  fun createOrValidate( testName: String, fileName: String, contents: String ): TestCase {
    testNameUnder = testName.replace( "/", "_" );

    inputFolder = Path.join( this.inputsFolder, testNameUnder);
    outputFolder = Path.join( this.outputsFolder, testNameUnder);

    FileSystem.ensureDirectory( inputFolder );
    FileSystem.ensureDirectory( outputFolder );

    inputPath = Path.join( inputFolder, fileName );
    outputPath = Path.join( outputFolder, fileName );

    msg = if ( ! FileSystem.exists( inputPath ) ){
      if (this.log) {
        print_string( `Creating snapshot file ${inputPath}` )
      };

      FileSystem.writeTextFile( inputPath, contents );

      None()
    } else {
      FileSystem.writeTextFile( outputPath, contents );
      expected = FileSystem.readTextFile( inputPath );

      if ( expected != contents ){
        Some( `Produced output is different, see 'diff ${inputPath} ${outputPath}'` )
      } else {
        None()
      }
    };

    TestCase( `${this.snapshotName}/${testName}/${fileName}`, msg )
  }
}

// An overall runner of test, encapsulating snapshot tests and TestHarness
mutable class .TestRunner(
  stdLib: String,
  harness: mutable TestHarness,
  flattenerSnapshot: SnapshotTest,
  translatorSnapshot: SnapshotTest,
  linearizedSnapshot: SnapshotTest,
  readerErrorSnapshot: SnapshotTest
){
  static fun mcreate( stdLib: String, inputSnapshotFolder: String, outputSnapshotFolder: String ): mutable this {
    mkSnapshot = name ~> {
      SnapshotTest(
        name,
        Path.join( inputSnapshotFolder, name ),
        Path.join( outputSnapshotFolder, name ),
        true
      )
    };

    mutable TestRunner(
      stdLib,
      TestHarness::mcreate(),
      mkSnapshot("flattener"),
      mkSnapshot("translator"),
      mkSnapshot("linearized"),
      mkSnapshot("readerError")
    );
  }

  readonly fun prepareFiles( files: Vector<String> ): (String, Vector<String>){
    name = Path.dirname( files[0] );

    // Prepend the stdLib
    paths = Vector::mcreate( files.size() + 1 );
    paths.push( this.stdLib );
    paths.extend( files );

    (name, paths.chill())
  }

  mutable fun good_test( files: Vector<String>, expectedValue: Interpreter.Val ): mutable this {
    (name, paths) = this.prepareFiles( files );

    res = this.run_test( paths, mutable NoOpIO(), name );
    this.harness.pushTestCase( res.assert_val( name, expectedValue ) );
    this
  }

  mutable fun reader_fail (files: Vector<String> ): mutable this {
    (name, paths) = this.prepareFiles( files );

    (rs, _) = Reader::process(paths);
    for ( r in rs ){
      if ( !r.ok ){
        case = this.readerErrorSnapshot.createOrValidate( name, "err", r.error );
        this.harness.pushTestCase( case );
        return this;
      }
    };

    this.harness.pushTestCase( TestCase( name, Some("Reader should have failed, it did not")) );
    this
  }

  mutable fun io_test( files: Vector<String>, reads: Vector<String>, writes: Vector<String> ): mutable this {
    (name, paths) = this.prepareFiles( files );
    io = MockIO::mcreate( reads );

    runRes = this.run_test( paths, io, name );
    this.harness.pushTestCase( runRes.assert_no_fail( name ) );

    ioRes = io.validateWrites( "io/" + name, writes );
    this.harness.pushTestCase( ioRes );
    this
  }

  mutable fun run_test(files: Vector<String>, io: mutable InterpreterIO, testName: String): TestResult {
    (rs, fs) = Reader::process(files);
    for ( r in rs ){
      if (!r.ok){
        return ReaderError( r.error );
      };
    };

    flat = mutable Flattener();
    flatFs = fs.map( f -> flat.file(f) );
    pp = mutable PrettyPrint();
    flatFs.filter(f -> f.name.lowercase() != "stdlib").each( f -> {
      prettyOut = pp.file(f);
      case = this.flattenerSnapshot.createOrValidate( testName, f.name, prettyOut );
      this.harness.pushTestCase( case );
    });

    t = Translator();
    translated = flatFs.map(d -> t.file(d));
    translated.filter(m -> m.name.lowercase() != "stdlib").each(m -> {
      prettyOut = (mutable PrettyPrint2()).toModule(m);
      case = this.translatorSnapshot.createOrValidate( testName, m.name, prettyOut );
      this.harness.pushTestCase( case );
    });

    l = Interpreter.Linearize::mcreate();
    linearized: Vector<Interpreter.Module> = translated.map(m -> l.mod(m));
    linearized.filter(m -> m.name.lowercase() != "stdlib").each(m -> {
      prettyOut = (mutable Interpreter.PrettyPrint(false)).toModule(m);
      case = this.linearizedSnapshot.createOrValidate( testName, m.name, prettyOut );
      this.harness.pushTestCase( case );
    });

    Interpreter.runProgram( linearized, io ) match {
      | Success(val) -> Successful(val)
      | Failure(msg) -> ExecutionError(msg)
    };
  }
}

// Do-nothing interpreter IO
mutable class NoOpIO() extends InterpreterIO {
  readonly fun read(): Option<String> {
    None()
  }

  readonly fun write(_: String): void {
    void
  }
}

mutable class MockIO( reads: Vector<String>, mutable readIdx: Int, writes: mutable Vector<String> ) extends InterpreterIO {
  static fun mcreate(reads: Vector<String>): mutable MockIO {
    mutable MockIO( reads, 0, Vector<String>::mcreate() )
  }

  mutable fun read(): Option<String> {
    if ( this.readIdx < this.reads.size() ){
      res = this.reads[this.readIdx];
      this.!readIdx = this.readIdx + 1;
      Some( res )
    } else {
      None()
    }
  }

  mutable fun write(line: String): void {
    this.writes.push(line)
  }

  readonly fun validateWrites(testName: String, expectedWrites: Vector<String>): TestCase{
    msg = if ( this.writes.size() < expectedWrites.size() ){
      Some("Not enought writes")
    } else if ( this.writes.size() > expectedWrites.size() ){
      Some("Too many writes")
    } else {
      this.writes.zipWith( expectedWrites, (val, expected) -> {
        if ( val != expected ) {
          Some(`Expected write ${expected}, actually ${val}`)
        } else {
            None()
        }
      }).filterNone()
      .maybeGet( 0 )
    };

    TestCase( testName, msg )
  }
}
