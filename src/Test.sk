module Test;

// A name of the test and optional error message
value class TestCase(name: String, message: Option<String>){}

// Result of complete run
base class TestResult(){
  children =
  | Successful( Interpreter.Val )
  | ReaderError( String )
  | CheckerError( String )
  | FlattenerError( String )
  | InterpreterError( String )
  | ExceptionError ( String )

  fun defaultMessage(): String {
    this match {
      | Successful(val) ->       `Expected failure, got ${val}`
      | ReaderError(msg) ->      `Reader failed with message: ${msg}`
      | CheckerError(msg) ->     `Checker failed with message: ${msg}`
      | FlattenerError(msg) ->   `Flattener failed with message: ${msg}`
      | InterpreterError(msg) -> `Execution failed with message: ${msg}`
      | ExceptionError(msg) ->   `Exception was raised: ${msg}`
    }
  }

  // Assert that result equals to a expected value
  fun assert_val( name: String, expectedValue: Interpreter.Val ): TestCase {
    msg = this match {
      | Successful(val) if (val == expectedValue) -> {
        None()
      }
      | Successful(val) -> {
        Some( `Expected result ${expectedValue}, got ${val}` )
      }
      | _ -> {
        Some( this.defaultMessage() )
      }
    };
    TestCase(name, msg)
  }

  fun assert_no_fail( name: String ): TestCase {
    msg = this match {
      | Successful(_) -> {
        None()
      }
      | _ -> {
        Some( this.defaultMessage() )
      }
    };
    TestCase(name, msg)
  }

  // Assert that execution failed in runtime
  fun assert_execution_fail( name: String ): TestCase {
    msg = this match {
      | InterpreterError(_) -> {
        None()
      }
      | _ -> {
        Some( this.defaultMessage() )
      }
    };
    TestCase(name, msg)
  }

  fun assert_checker_fail( name: String ): TestCase {
    msg = this match {
      | CheckerError(_) -> {
        None()
      }
      | _ -> {
        Some( this.defaultMessage() )
      }
    };
    TestCase(name, msg)
  }
}

// A class for collecting TestCases
mutable class TestHarness( tests: mutable Vector<TestCase> ){

  static fun mcreate() : mutable this {
    mutable TestHarness( mutable Vector<TestCase>[] )
  }

  mutable fun pushTestCase( case: TestCase ): void {
    this.tests.push( case )
  }


  // Report all failed tests and the count of all, failed and succesful tests
  readonly fun report(): String {
    allCnt = this.tests.size();
    successfulCnt = this.tests.filter( test -> test.message.isNone() ).size();
    maxTestNameSize = this.tests.map( test -> test.name.length() ).max().default( 0 );
    errs: Vector<String> = this.tests.map( test -> test.message match {
      | Some( msg ) -> Some( `    ${test.name.padRight( maxTestNameSize, ' ' )} ${msg}`  )
      | None() -> None()
    }).filterNone();
    unsuccessfulCnt = errs.size();

    err = if ( unsuccessfulCnt != 0 ){
      "Errors:\n" +
      "\n".join( errs ) +
      "\n\n"
    } else {
      ""
    };

    err +
    `Total tests:   ${allCnt}\n` +
    `Failed tests:  ${unsuccessfulCnt}\n` +
    `Passing tests: ${successfulCnt}\n`
  }
}

// A file-based test that creates a file (snapshot) that captures the expected output,
// or if it already exists, validates that the current output matches the expected one
class SnapshotTest( snapshotName: String, inputsFolder: String, outputsFolder: String){
  fun createOrValidate( testName: String, fileName: String, contents: String ): TestCase {
    testNameUnder = testName.replace( "/", "_" );

    inputFolder = Path.join( this.inputsFolder, testNameUnder);
    outputFolder = Path.join( this.outputsFolder, testNameUnder);

    FileSystem.ensureDirectory( inputFolder );
    FileSystem.ensureDirectory( outputFolder );

    inputPath = Path.join( inputFolder, fileName );
    outputPath = Path.join( outputFolder, fileName );

    msg = if ( ! FileSystem.exists( inputPath ) ){
      print_string( `Creating snapshot file ${inputPath}` );
      FileSystem.writeTextFile( inputPath, contents );
      None()
    } else {
      FileSystem.writeTextFile( outputPath, contents );
      expected = FileSystem.readTextFile( inputPath );

      if ( expected != contents ){
        Some( `Produced output is different, see 'diff ${inputPath} ${outputPath}'` )
      } else {
        None()
      }
    };

    TestCase( `${this.snapshotName}/${testName}/${fileName}`, msg )
  }
}

// An overall runner of test, encapsulating snapshot tests and TestHarness
mutable class .TestRunner(
  stdLib: String,
  harness: mutable TestHarness,
  flattenerSnapshot: SnapshotTest,
  linearizedSnapshot: SnapshotTest,
  checkerErrorSnapshot: SnapshotTest
){
  static fun mcreate( stdLib: String, inputSnapshotFolder: String, outputSnapshotFolder: String ): mutable this {
    mkSnapshot = name ~> {
      SnapshotTest(
        name,
        Path.join( inputSnapshotFolder, name ),
        Path.join( outputSnapshotFolder, name )
      )
    };

    mutable TestRunner(
      stdLib,
      TestHarness::mcreate(),
      mkSnapshot("flattener"),
      mkSnapshot("linearized"),
      mkSnapshot("checkerError")
    );
  }

  readonly fun prepareFiles( files: Vector<String> ): (String, Vector<String>){
    name = Path.dirname( files[0] );

    // Prepend the stdLib
    paths = Vector::mcreate( files.size() + 1 );
    paths.push( this.stdLib );
    paths.extend( files );

    (name, paths.chill())
  }

  mutable fun good_test( files: Vector<String>, expectedValue: Interpreter.Val ): mutable this {
    (name, paths) = this.prepareFiles( files );

    res = this.run_test( paths, mutable NoOpIO(), name );
    this.harness.pushTestCase( res.assert_val( name, expectedValue ) );
    this
  }

  mutable fun execution_fail( files: Vector<String> ): mutable this {
    (name, paths) = this.prepareFiles( files );

    res = this.run_test( paths, mutable NoOpIO(), name );
    this.harness.pushTestCase( res.assert_execution_fail( name ) );
    this
  }

  mutable fun checker_fail( files: Vector<String> ): mutable this {
    (name, paths) = this.prepareFiles( files );

    res = this.run_test( paths, mutable NoOpIO(), name );
    case = res.assert_checker_fail( name );
    this.harness.pushTestCase( case );

    res match {
      | CheckerError(err) -> {
        snapCase = this.checkerErrorSnapshot.createOrValidate( name, "err", err );
        this.harness.pushTestCase( snapCase )
      }
      | _ -> void
    };

    this
  }

  mutable fun io_test( files: Vector<String>, reads: Vector<String>, writes: Vector<String> ): mutable this {
    (name, paths) = this.prepareFiles( files );
    io = MockIO::mcreate( reads );

    runRes = this.run_test( paths, io, name );
    this.harness.pushTestCase( runRes.assert_no_fail( name ) );

    ioRes = io.validateWrites( "io/" + name, writes );
    this.harness.pushTestCase( ioRes );
    this
  }

  mutable fun run_test(files: Vector<String>, io: mutable InterpreterIO, testName: String): TestResult {
    Result::guard( () -> {
      fs = Reader::process(files);

      flat = mutable Flattener();
      flatFs = fs.map( f -> flat.file(f) );
      flatFs.filter(m -> m.name.lowercase() != "stdlib").each(m -> {
        prettyOut = FlattenedPrettyPrint::prettyPrint(m);
        case = this.flattenerSnapshot.createOrValidate( testName, m.name, prettyOut );
        this.harness.pushTestCase( case );
      });

      l = Interpreter.Linearize::mcreate();
      linearized: Vector<Interpreter.Module> = flatFs.map(m -> l.mod(m));
      linearized.filter(m -> m.name.lowercase() != "stdlib").each(m -> {
        prettyOut = m.toString();
        case = this.linearizedSnapshot.createOrValidate( testName, m.name, prettyOut );
        this.harness.pushTestCase( case );
      });

      Interpreter.runProgram( linearized, io ) match {
        | Success(val) -> Successful(val)
        | Failure(msg) -> InterpreterError(msg)
      };
    }) match {
      | Success(res) -> res
      | Failure( ReaderException(msg) ) -> ReaderError( msg )
      | Failure( CheckerException(msg) ) -> CheckerError( msg )
      | Failure( FlattenerException(msg) ) -> FlattenerError( msg )
      | Failure(e) -> ExceptionError( e.getMessage() )
    }
  }
}

// Do-nothing interpreter IO

mutable class NoOpIO() extends InterpreterIO {
  readonly fun read(): Option<String> {
    None()
  }

  readonly fun write(_: String): void {
    void
  }
}

mutable class MockIO( reads: Vector<String>, mutable readIdx: Int, writes: mutable Vector<String> ) extends InterpreterIO {
  static fun mcreate(reads: Vector<String>): mutable MockIO {
    mutable MockIO( reads, 0, Vector<String>::mcreate() )
  }

  mutable fun read(): Option<String> {
    if ( this.readIdx < this.reads.size() ){
      res = this.reads[this.readIdx];
      this.!readIdx = this.readIdx + 1;
      Some( res )
    } else {
      None()
    }
  }

  mutable fun write(line: String): void {
    this.writes.push(line)
  }

  readonly fun validateWrites(testName: String, expectedWrites: Vector<String>): TestCase{
    msg = if ( this.writes.size() < expectedWrites.size() ){
      Some(`Not enought writes, expected ${expectedWrites}, actually ${this.writes}`)
    } else if ( this.writes.size() > expectedWrites.size() ){
      Some(`Too many writes, expected ${expectedWrites}, actually ${this.writes}`)
    } else {
      this.writes.zipWith( expectedWrites, (val, expected) -> {
        if ( val != expected ) {
          Some(`Expected write ${expected}, actually ${val}`)
        } else {
          None()
        }
      }).filterNone()
      .maybeGet( 0 )
    };

    TestCase( testName, msg )
  }
}
