module Reader;

type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;
type VMap = mutable Map<String, String>;
type Exprs = Vector<Expr>;

value class Module(name: String, imports: Strings, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Code, locals: Int) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
  | Set(Register, Exp)
  | GSet(Register, Exp)
  | Loop(Exp, Code)
  | Branch(Exp, Code, Code)
  | Return(Exp) // TODO: Return(Register)
  //this means that the Flattener needs to turn the last expression in
  //Function into a return (and store the result into the register
  //first).  This will be helped when we check sanity of function
  //definitions. See comment on top of Checker.sk
}

base class Exp {
  children =
  | VInt(Int)
  | VBool(Bool)
  | VString(String)
  | VChar(Char)
  | VList(content: Vector<Register>)
  | Register(name: String)
  | Load(String) // TODO: can all loads be statements? would make expr simpler, but we already have invoke
  | Invoke(String, Vector<Register>)
}


class .Translator() {

  fun file(f: File): Module {
    globals = f.decls.size();
    funs = f.funs.map(f -> this.function(f));
    Module(f.name, f.imports, globals, funs)
  }

  fun expression(e0: Expr): Exp {
    e0 match {
     | LitInt(_, i) -> VInt(i)
     | LitBool(_, b) -> VBool(b)
     | LitChar(_, c) -> VChar(c)
     | LitString(_, s) -> VString(s)
     | LitList(_, exs) -> VList(exs.map(e -> this.var(e)))
     | Var(_, s) -> Register(s)
     | Call(_, n, es) -> {
        if (n == "load") {
          regName = es[0] match { Var(_, name) -> name | _ -> "ERROR" };
          Load(regName)
        } else {
          args = es.map(e -> e match { | Var(_, n1) -> Register(n1) | _ -> Register("ERROR") });
          Invoke(n, args)
        }
     }
     | _ -> VInt(0)
    }
  }

  fun statement(e0: Expr): Statements {
    e0 match {
    | Call(_, n, es) -> {
      s = if (n == "set!") Set(this.var(es[0]), this.expression(es[1]))
      else if (n == "gset!") GSet(this.var(es[0]), this.expression(es[1]))
            else Set(Register("ERROR"), VInt(0));
      Statements[s]
    }
    | Decl(_, n, e) -> Statements[Set(Register(n), this.expression(e))]
        | Block(_t, es) -> es.map(e -> this.statement(e)).flatten()
        | While(_, e, s) -> Statements[Loop(this.expression(e), Code(this.statement(s)))]
        | Cond(_, e, s1, s2) -> Statements[Branch(this.expression(e),
                                         Code(this.statement(s1)), Code(this.statement(s2)))]
    | e -> Statements[Return(this.expression(e))]
    }
  }

  fun var(e: Expr): Register {
    e match { | Var(_, str) -> Register(str) | _ -> Register("ERROR") }
  }

  fun function(f: Function): Fun { Fun(f.name, f.params.size(), Code(this.statement(f.body)), f.locals)  }
}



mutable class .Flattener(mutable v: Int = 0, glob: VMap = Map::mcreate(), mutable funs: Functions = Functions[]) {

  mutable fun file(f: File): File {
    this.glob.clear();
    this.!v = 0;

    newFuns = mutable Functions[];
    newFuns.extend(this.funs);
    newFuns.extend(f.funs);
    this.!funs = newFuns.chill();
		// we need to preserve all the functions in all the modules.  even
    // thought, this approach seems to be susceptible to bugs.  the
    // order in which the modules are processed matters, but that
    // order is not really the order of dependencies

    f.decls.each(d -> d match { | Decl(_, n, _) -> { this.glob.add(n, this.nextVar());}});
    v = mutable Exprs[];
    v.extend(f.decls.map(d -> d match { | Decl(t, n, e) -> Call(t, "gset!", Exprs[Var(t, n), e])}));
    varname = "success";
    v.extend(Exprs[Decl(f.tok, varname, LitInt(f.tok, 0)), Var(f.tok, varname)]); // return 0
    b = Block(f.tok, v.chill());
    init = Function(f.tok, "init", Strings[], None(), b, this.v);
    funs = Vector::mcreateFromItems(f.funs);
    funs.push(init);
    fs = funs.map(f -> this.function(f));
    File(f.tok, f.name, f.imports, f.decls, fs)
  }

  mutable fun function(f: Function): Function {
    locals : VMap = Map::mcreate();
    this.!v = 0;
    if (f.polyArg.isSome()) {
      this.polyFunction(f)
    } else {
      f.params.each(p -> locals.add(p, this.nextVar()));
      _ = f.polyArg.map(str -> locals.add(str, this.nextVar()));
      (es, e) = this.expression(f.body, locals);
      Function(f.tok, f.name, f.params, f.polyArg, this.toBlock(f.tok, es, e), this.v)
    }
  }

  mutable fun polyFunction(f: Function): Function {
    locals : VMap = Map::mcreate();
    this.!v = 0; // just to show that it's done

    origParamCnt = f.params.size();
    if (f.polyArg.isSome()) { !origParamCnt = origParamCnt + 1; };

    aname = this.nextVar();
    argVar = Var(f.tok, aname);
    locals.add(aname, aname);

    // rewrite all the parameters into something like
    // Decl(<original token>, <original name>, Call(<original token>, "at", Vector[<original name>, <position>]))
    // this needs to become a part of the body of the function, so I need to prepend it before transformation
    unlistParams
      = f.params.mapWithIndex((pos, name) -> Decl(f.tok, name, Call(f.tok, "at", Exprs[argVar, LitInt(f.tok, pos)])));
    // all of this will go into a body
    // they "redefine" original parameters and we make up a new, singular parameter (inside `argVar`)

    unlistRest = f.polyArg.map(str -> Exprs[Decl(f.tok,str,
							 Call(f.tok, "drop", Exprs[LitInt(f.tok, f.params.size()), argVar]))]).default(Exprs[]);

    body = mutable Exprs[];
    body.extend(unlistParams);
    body.extend(unlistRest);
    body.push(f.body);

    (es, e) = this.expression(Block(f.tok, body.chill()), locals);

    params = Strings[aname]; // There's always just this one "arguments"

    Function(f.tok, f.name, params, None(), this.toBlock(f.tok, es, e), this.v)
  }

  readonly fun arityOf(fname: String): Arity {
    this.funs.find(f -> f.name == fname) match {
      | Some(f) ->
          f.polyArg match {
            | None() -> Exactly(f.params.size())
            | Some(_) -> AtLeast(f.params.size())
          }
      | None() -> // WILL NEVER HAPPEN
          Exactly(-1)
    }
  }

  readonly fun undef(): Expr { Var(Tok(), " Error") }

  readonly fun isUndef(e : Expr): Bool { e match { | Var(_,s) -> s == " Error" | _ -> false } }

  mutable fun nextVarId(): Int {
     id = this.v;
    this.!v = this.v + 1;
    id
  }

  mutable fun nextVar(): String { `%${this.nextVarId()}` }

  readonly fun toBlock(t: Tok, es: mutable Exprs, e: Expr): Expr {
    if (!this.isUndef(e)) { es.push(e);  };
    if (es.size() > 1) { Block(t, es.chill()) } else if (es.size() == 1) { es[0]} else { this.undef() }
   }

  readonly fun toRegister(varname: String, locals: VMap): String {
    if (locals.containsKey(varname)) {
      locals.get(varname)
    } else if (this.glob.containsKey(varname)) {
      this.glob.get(varname)
    } else {
      varname
    }
  }

  mutable fun expression(e0: Expr, locals: VMap): (mutable Exprs, Expr) {
    ve = mutable Exprs[];
    undef = this.undef();
    e0 match {
    | LitInt(t, _)
    | LitBool(t, _)
    | LitChar(t, _)
    | LitString(t, _) -> {
      varname = this.nextVar();
      (mutable Exprs[Decl(t, varname, e0)], Var(t, varname))
    }
    | LitList(t, _) -> {
      // THIS WILL NEVER HAPPEN
      ve.push(Var(t, "ERROR"));
      (ve, undef)
    }
    | Var(t, n) -> {
      vname = this.toRegister(n, locals);
      if (locals.containsKey(n)) {
        (ve, Var(t, vname))
      } else if (this.glob.containsKey(n)) {
        x = Call(t, "load", Exprs[Var(t, vname)]);
        nvar = this.nextVar();
        assign = Decl(t, nvar, x);
        ve.push(assign);
        (ve, Var(t, nvar))
      } else {
        (ve, undef)
      }
    }
    | Decl(t, n, e) -> {
       (v2, e2) = this.expression(e, locals);
      varname = this.nextVar();
      locals.add(n, varname);
      v2.push(Decl(t, varname, e2));
      (v2, undef)
    }
    | Call(t, n, es) -> {
      es2 = mutable Exprs[];
      if (n == "set!") {
         (vexp, exp) = (es[0], es[1]);
         (tok, origVName) = vexp match {| Var(t2, nm) -> (t2, nm) | _ -> (t, "Error")};
         !n = if (this.glob.containsKey(origVName)) { "gset!" } else { "set!" };
         vname = this.toRegister(origVName, locals);
         (v2, e2) = this.expression(exp, locals);
         args = Exprs[Var(tok, vname), e2];
         v2.push(Call(t, n, args));
         (v2, undef)
      } else if (n == "gset!") {
        (tok, origVName) = es[0] match {| Var(t2, nm) -> (t2, nm) | _ -> (t, "Error")};
        vname = this.toRegister(origVName, locals);
        (v2, e2) = this.expression(es[1], locals);
        args = Exprs[Var(tok, vname), e2];
        v2.push(Call(t, n, args));
        (v2, undef)
      } else {
        _argsCnt = es.size();
        arity = this.arityOf(n);
        arity match {
          | Exactly(_) -> {
            // that `n` must be equal to `argsCnt`, but at this point it will
            es.each(e -> {
              (v2, e2) = this.expression(e, locals);
              es2.push(e2);
              ve.extend(v2.chill());
            });
            varname = this.nextVar();
            ve.push(Decl(t, varname, Call(t, n, es2.chill())));
            (ve, Var(t,varname))
          }
          | AtLeast(_) -> {
            // that `ordCnt` must be smaller than `argsCnt`, but at
            // this point it will I will have to construct a new
            // variable and store a list in it that list will contain
            // all the additional arguments (rest of `es`) so I take
            // first `n` arguments and deal with them the same way as
            // above but then I create a new variable after I deal
            // with the rest of the arguments in such a way that the
            // new variable can host a List that contains all the
            // second parts of each tuple I then construct the call,
            // it will be almost exactly what is above, but I will
            // push one more argument to it that will be the new
            // variable with the list

            // we know that every polyvariadic function is translated
            // into a function with a single parameter we therefore
            // need to put all the arguments into a list and only pass
            // that list into the call

            // TODO: there are no ordinary arguments, everything goes into a list together with the rest thing
            // ordinary = es.slice(0, ordCnt); // only first `n` arguments
            // ordinary.each(e -> {
            //   (v2, e2) = this.expression(e, locals);
            //   es2.push(e2);
            //   ve.extend(v2.chill());
            // });

            // rest = es.slice(ordCnt); // until the end
            listvars = mutable Exprs[];
            // all original arguments will be flattened and put into a list-value
            es.each(e -> {
              (v2, e2) = this.expression(e, locals);
              listvars.push(e2);
              ve.extend(v2.chill());
            });
            listvarname = this.nextVar();
            ve.push(Decl(t, listvarname, LitList(t, listvars.chill())));
            es2.push(Var(t, listvarname));
            varname = this.nextVar();
            ve.push(Decl(t, varname, Call(t, n, es2.chill())));
            (ve, Var(t,varname))
          }
        }
      }
    }
    | Block(_, es) -> {
      last = undef;
      es.each(e -> {
        (v2, e2) =  this.expression(e, locals);
        ve.extend(v2.chill());
        !last = e2;
      });
      (ve, last)
    }
    | While(t, e, s) -> {
      (v2, e2) = this.expression(e, locals);
      ve.extend(v2.chill());
      (v3, _) = this.expression(s, locals);
      v3.extend(v2.chill());
      ve.push(While(t, e2, this.toBlock(t, v3,  undef)));
      (ve, undef)
    }
    | Cond(t, e, s1, s2) -> {
      (v2, e2) = this.expression(e, locals);
      ve.extend(v2.chill());
      (v3, _) = this.expression(s1, locals);
      (v4, _) = this.expression(s2, locals);
      ve.push(Cond(t, e2, this.toBlock(t, v3, undef), this.toBlock(t, v4, undef)));
      (ve, undef)
    }
    }
  }
}



mutable class .PrettyPrint2(mutable indent: Int = 0) {

  readonly fun pad(): String {
    s = "";  n = this.indent;
    while (n > 0) { !s = s + " "; !n = n - 1; };
    s
  }

  mutable fun toModule(f: Module): String {
    s = `(module ${f.name} imports (`;
    f.imports.each(s -> !s = s + s + " ");
    // !s = `${s})\n(vars (`;
    !s = s + `(functions (`;
    if (f.funs.size() == 0) {
      !s = s + "))\n";
    } else {
      this.inc();
      f.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
       !s = s + "\n))\n";
      this.dec();
    };
    s
  }

  mutable fun function(f: Fun): String {
    params = `${f.params}`;
    s = `(function ${f.name}(${params} | ${f.locals}`;
    !s = s + ") ";
    this.inc();
    !s = s + this.code(f.body);
    this.dec();
    !s = s + ")\n";
    s
  }

  mutable fun code(c: Code): String {
    res = "";
    c.stmts.each(s -> {
      !res = res + "\n" + this.pad() + this.statement(s);
    });
    res
  }

  mutable fun expression(e0: Exp): String {
    e0 match {
    | VInt(i) -> `${i}`
    | VBool(b) -> `${b}`
    | VString(s) -> `"${s}"`
    | VChar(ch) -> `'${ch}'`
    | VList(regs) -> `[${regs.map( r -> this.expression(r) ).join( ", " )}]`
    | Register(s) -> s
    | Load(s) -> `load ${s}`
    | Invoke(n, es) -> `(${n} ${es.map( e -> this.expression(e)).join( " " )})`
    }
  }

  mutable fun statement(st: Stmt): String {
    st match {
    | Set(n, e) -> `${this.expression(n)} = ${this.expression(e)}`
    | GSet(n, e) -> `${this.expression(n)} ^= ${this.expression(e)}`
    | Loop(e, s) -> "while " + this.expression(e) + " " + this.code(s)
    | Branch(e, s1, s2) -> {
      s = "(if " + this.expression(e) + "\n";
      this.inc();
      !s = s + this.code(s1) + "\n" + this.code(s2) + ")";
      this.dec();
      s
    }
    | Return(e) -> `return ${this.expression(e)}`
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }

}

module end;
