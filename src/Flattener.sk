module Reader;

type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;
type VMap = mutable Map<String, ScopedVariable>;
type Exprs = Vector<Expr>;

value class Module(name: String, imports: Strings, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Code, locals: Int) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
  | Set(Register, Exp)
  | GSet(Register, Exp)
  | ArrSet(Register, Exp, Exp) // Register with array, index and value
  | GArrSet(Register, Exp, Exp)
  | Loop(Register, Code)
  | Branch(Register, Code, Code)
  | Return(Register)

  fun toString(): String {
	  this match {
     | Set(r, e) -> `(set! ${r.toString()} ${e.toString()})`
     | GSet(r, e) -> `(gset! ${r.toString()} ${e.toString()})`
     | ArrSet(r, i, e) -> `(arr_set! ${r.toString()} ${i.toString()} ${e.toString()})`
     | GArrSet(r, i, e) -> `(garr_set! ${r.toString()} ${i.toString()} ${e.toString()})`
     | Loop(e, _c) -> `(while (${e.toString()}) ... )`
     | Branch(e, _, _) -> `(if (${e.toString()} (...) (...))`
     | Return(e) -> `(ret ${e.toString()} )`
    }
  }
}

base class Exp {
  children =
  | VInt(Int)
  | VBool(Bool)
  | VString(String)
  | VChar(Char)
  | VList(content: Vector<Register>)
  | VClosure(funName: String, arity: Int, isVarArg: Bool)
  | Register(id: Int)
  | Load(Int) // TODO: can all loads be statements? would make expr simpler, but we already have invoke
  | Invoke(String, Vector<Register>)
  | IndirectInvoke(Register, Vector<Register>)

  fun toString(): String {
	  this match {
     | VInt(v) -> `${v}`
     | VBool(v) -> `${v}`
     | VString(v) -> `${v}`
     | VChar(v) -> `${v}`
     | VList(_v) -> `[...]`
     | VClosure(fname, _, _) -> `<closure:${fname}>`
     | Register(name) -> `%${name}`
     | Load(v)  -> `g${v}`
     | Invoke(f, _vs) -> `(${f} ...)`
     | IndirectInvoke(reg, _vs) -> `(${reg} ...)`
		}
  }
}

// Flatenner exception class
class .FlattenerException(message: String) extends Exception{
  fun getMessage(): String {
    "Flattener error: " + this.message
  }
}

base class ScopedVariable() {
  children =
  | GlobalRegister( reg: Register )
  | LocalRegister( reg: Register )
  | ScopedFunction( fname: String, argCount: Int, hasPolyArg: Bool )
}


mutable class .Flattener(mutable v: Int = 0, funs: mutable Vector<ScopedFunction> = Vector::mcreate()) {
  static fun process( fs: Vector<File> ): Vector<Module> {
    flat = mutable Flattener();
    fs.map( f -> flat.file(f) )
  }

  // Adds all global variables to the scope and creates a init function with initialization values
  mutable fun handleGlobals(f: File): (Function, VMap) {
    // Body of the init function
    v = mutable Exprs[];
    globs: VMap = Map::mcreate();

    // For each global variable -> add it to scope and add a initialization statement to the body
    f.decls.items().each(tup -> tup match { | (idx, Decl(t, n, e)) -> {
      globs.add( n, GlobalRegister(Register(idx)) );

      // Does not need to be global set, it is transformed automatically
      v.push( Call(t, "set!", Exprs[ Var(t, n), e ]) )
    }});

    // Return 0
    v.push(LitInt(f.tok, 0));

    b = Block(f.tok, v.chill());

    newFun = Function(f.tok,
      "init", // name
      Strings[], // params
      None(), // polyArg
      b, // body
      0 // locals
    );

    (newFun, globs)
  }

  mutable fun file(f: File): Module {
    // we need to preserve all the functions in all the modules.  even
    // thought, this approach seems to be susceptible to bugs.  the
    // order in which the modules are processed matters, but that
    // order is not really the order of dependencies
    f.funs
      .map( func -> ScopedFunction( func.name, func.params.size(), func.polyArg.isSome() ) )
      .each( func -> this.funs.push( func ) );

    // Handle globals, create the init function
    (init, moduleScope) = this.handleGlobals(f);

    // Add all functions to module scope
    // do not override global variables with funciton names
    this.funs.each( func -> _ = moduleScope.maybeSet( func.fname, func ) );

    // Flatten all functions
    fs = f.funs.cat(init).map(f -> this.function(f, moduleScope.clone()));
    Module( f.name, f.imports, f.decls.size(), fs )
  }

  mutable fun function(f: Function, scope: VMap): Fun {
    this.!v = 0;

    // Handle locals, body and parameters
    // is different for polyArg functions
    (body, pCount) = if (f.polyArg.isSome()) {
      this.polyFunction(f, scope)
    } else {
      f.params.each(p -> scope.add(p, LocalRegister( this.nextReg() )));
      (f.body, f.params.size())
    };

    (es, e) = this.expression(body, scope);
    e match {
      | None() -> this.fail( f.tok, `Missing return in ${f.name}` )
      | Some(val) -> !es = es.cat( Return(val) )
    };

    Fun( f.name, pCount, Code( es ), this.v )
  }

  // The parameters of poly function work like this
  // (function foo(a b ...c) body)
  // is rewritten to
  // (function foo(param)
  //  (begin
  //    (let a (at param 0))
  //    (let b (at param 1))
  //    (let c (drop param 2))
  //    body
  //  )
  // )
  // returns (locals, body of the new function, new parameters)
  mutable fun polyFunction(f: Function, scope: VMap): (Expr, Int) {
    aname = "#argVar";
    argVar = Var(f.tok, aname);
    scope.add(aname, LocalRegister( this.nextReg() ));

    // rewrite all the parameters into something like
    // Decl(<original token>, <original name>, Call(<original token>, "at", Vector[<original name>, <position>]))
    // this needs to become a part of the body of the function, so I need to prepend it before transformation
    unlistParams = f.params.mapWithIndex((pos, name) ->
      Decl(f.tok, name, Call(f.tok, "at", Exprs[argVar, LitInt(f.tok, pos)]))
    );

    // all of this will go into a body
    // they "redefine" original parameters and we make up a new, singular parameter (inside `argVar`)
    unlistRest = f.polyArg.map(str ->
      Exprs[Decl(f.tok,str, Call(f.tok, "drop", Exprs[LitInt(f.tok, f.params.size()), argVar]))]
    ).default(Exprs[]);

    body = mutable Exprs[];
    body.extend(unlistParams);
    body.extend(unlistRest);
    body.push(f.body);

    bodyExpr = Block(f.tok, body.chill());

    (bodyExpr, 1)
  }

  /*****************************************/
  // helpers

  readonly fun fail<T>(tok: Tok, message: String): T {
    errMsg = tok.error_message(message);
    throw FlattenerException( errMsg )
  }

  readonly fun asVar(e: Expr): (Tok, String) {
    e match {
      | Var(t, s) -> (t, s)
      | _ -> this.fail(e.getToken(), "Not a variable" )
    }
  }

  mutable fun nextReg(): Register {
    reg = Register( this.v );
    this.!v = this.v + 1;
    reg
  }

  readonly fun findInScope( t: Tok, name: String, scope: VMap ): ScopedVariable {
    scope.maybeGet( name ) match {
      | Some(val) -> val
      | None() -> this.fail( t, `Name ${name} not found in any scope` )
    }
  }

  /*****************************************/
  // Expression flattening

  mutable fun literal(exp: Exp): (Statements, Option<Register>) {
    reg = this.nextReg();
    set = Statements[ Set( reg, exp ) ];
    (set, Some(reg))
  }

  // An expression where we enforce that the return register is present
  mutable fun expressionVal(e0: Expr, scope: VMap): (Statements, Register) {
    (v2, e2) = this.expression(e0, scope);
    e2 match {
      | Some(val) -> (v2, val)
      | None() -> this.fail( e0.getToken(), "Missing a expression result value")
    }
  }

  // Returns pair of the code and the last register where the return value is in
  mutable fun expression(e0: Expr, scope: VMap): (Statements, Option<Register>) {
    e0 match {
    | LitInt(_, i) ->    this.literal( VInt(i) )
    | LitBool(_, b) ->   this.literal( VBool(b) )
    | LitChar(_, c) ->   this.literal( VChar(c) )
    | LitString(_, s) -> this.literal( VString(s) )
    | Var(t, n) -> {
      this.findInScope(t, n, scope) match {
        | LocalRegister(reg) -> (Statements[], Some(reg))
        | GlobalRegister(reg) -> {
          localReg = this.nextReg();
          assign = Set(localReg, Load( reg.id ));
          (Statements[ assign ], Some(localReg))
        }
        | ScopedFunction( fname, args, isVarArg ) -> {
          localReg = this.nextReg();
          assign = Set(localReg, VClosure( fname, args, isVarArg ));
          (Statements[assign], Some(localReg) )
        }
      }
    }
    | Decl(_, n, e) -> {
      (exprBody, exprResult) = this.expressionVal(e, scope);
      reg = this.nextReg();
      scope.add(n, LocalRegister(reg));

      set = Set( reg, exprResult );
      (exprBody.cat(set), None())
    }
    | Call(t, "set!", es) -> {
      // (set! var assign)
      // is transformed to
      // assignResult = evaluated assign
      // var = assignResult
      (varTok, origVName) = this.asVar( es[0] );
      (assignBody, assignResult) = this.expressionVal(es[1], scope);

      set = this.findInScope( varTok, origVName, scope ) match {
        | GlobalRegister( reg ) -> GSet( reg, assignResult )
        | LocalRegister( reg ) -> Set( reg, assignResult )
        | ScopedFunction _ -> this.fail(t, "Trying to assign to a function")
      };

      (assignBody.cat(set), None())
    }
    | Call(t, "arr_set!", es) -> {
      // (arr_set! var idx assign)
      // is transformed to
      // idxResult = evaluated idx
      // assignResult = evaluated assign
      // var[idxResult] = assignResult
      (varTok, origVName) = this.asVar( es[0] );
      (idxBody, idxResult) = this.expressionVal(es[1], scope);
      (assignBody, assignResult) = this.expressionVal(es[2], scope);

      set = this.findInScope( varTok, origVName, scope ) match {
        | GlobalRegister( reg ) -> GArrSet( reg, idxResult, assignResult )
        | LocalRegister( reg ) -> ArrSet( reg, idxResult, assignResult )
        | ScopedFunction _ -> this.fail(t, "Trying to array set to a function")
      };

      (idxBody.concat(assignBody).cat(set) , None())
    }
    | Call(t, n, es) -> {
      body = mutable Statements[];
      params = mutable Vector<Register>[];

      es.each(e -> {
        (paramBody, param) = this.expressionVal(e, scope);
        body.extend(paramBody);
        params.push(param);
      });

      // The invoke statement
      call = this.findInScope( t, n, scope ) match {
        // Arguments of vararg functions are all passed in a list
        | ScopedFunction( _, _, isVarArg ) if (isVarArg) -> {
          // all original arguments will be flattened and put into a list-value
          // (foo a b c) will transform to
          // %0 = a
          // %1 = b
          // %2 = c
          // %3 = [a b c]
          // returnReg = foo %3
          // where %3 is listreg
          listreg = this.nextReg();
          body.push( Set(listreg, VList( params.chill() )) );

          Invoke( n, Vector<Register>[ listreg ] )
        }
        | ScopedFunction _ -> {
          Invoke( n, params.chill() )
        }
        | GlobalRegister(reg) -> {
          loadReg = this.nextReg();
          body.push( Set( loadReg, Load( reg.id )) );
          IndirectInvoke( loadReg, params.chill() )
        }
        | LocalRegister(reg) -> IndirectInvoke( reg, params.chill() )
      };

      returnRegister = this.nextReg();
      set = Set( returnRegister, call );
      body.push(set);

      (body.chill(), Some(returnRegister))
    }
    | Block(_, es) -> {
      body = mutable Statements[];
      last: Option<Register> = None();

      es.each(e -> {
        (nestedBody, res) = this.expression(e, scope);
        body.extend(nestedBody);
        !last = res
      });

      (body.chill(), last)
    }
    | While(_, e, s) -> {
      // (while expr body)
      // is transformed to
      // condVar = expr
      // loop condVar (
      //  body
      //  condVar = expr
      // )
      (condExpr, condVar) = this.expressionVal(e, scope);
      (whileBody, _) = this.expression(s, scope);

      loopStat = Loop(condVar, Code( whileBody.concat(condExpr) ));

      (condExpr.cat(loopStat), None())
    }
    | Cond(_, e, s1, s2) -> {
      // (if expr trueBody falseBody)
      // is transformed to
      // condVar = expr
      // if (condVar) {res = evaluated trueBody}
      // else {res = evaluated falseBody}
      // and the value of this statement is `res`
      (condExpr, condVar) = this.expressionVal(e, scope);
      (trueBlock, trueRes) = this.expression(s1, scope);
      (falseBlock, falseRes) = this.expression(s2, scope);

      res = (trueRes, falseRes) match {
        | (Some(tVal), Some(fVal)) -> {
          returnReg = this.nextReg();
          !trueBlock  = trueBlock.cat(  Set(returnReg, tVal) );
          !falseBlock = falseBlock.cat( Set(returnReg, fVal) );
          Some(returnReg)
        }
        | _ -> None()
      };

      branch = Branch( condVar, Code(trueBlock), Code(falseBlock) );
      (condExpr.cat(branch), res)
    }
    };
  }
}

mutable class .FlattenedPrettyPrint(mutable indent: Int = 0) {

  static fun prettyPrint(m: Module): String {
    pp = mutable FlattenedPrettyPrint();
    pp.toModule( m )
  }

  readonly fun pad(): String {
    " ".repeat(this.indent)
  }

  mutable fun toModule(f: Module): String {
    this.inc();
    functions = f.funs.map(f -> this.pad() + this.function(f))
      .join( "\n" );
    this.dec();

    `(module ${f.name} imports (${f.imports.join( " " )})\n` +
      "(functions (\n" +
      functions +
      "\n)))"
  }

  mutable fun function(f: Fun): String {
    this.inc();
    body = this.code(f.body);
    this.dec();

    `(function ${f.name}(${f.params} | ${f.locals})` +
      body +
      ")\n"
  }

  mutable fun code(c: Code): String {
    "\n" +
      c.stmts.map( s -> {
        this.pad() + this.statement(s)
      }).join("\n")
  }

  mutable fun expression(e0: Exp): String {
    e0 match {
    | VInt(i) -> `${i}`
    | VBool(b) -> `${b}`
    | VString(s) -> `"${s}"`
    | VChar(ch) -> `'${ch}'`
    | VList(regs) -> `[${regs.map( r -> this.expression(r) ).join( ", " )}]`
    | VClosure(fname, arity, isVarArg) -> `<closure:${fname}, argc=${arity}${if(isVarArg)"+" else ""}>`
    | Register(s) -> `%${s}`
    | Load(s) -> `load %${s}`
    | Invoke(n, es) -> `(${n} ${es.map( e -> this.expression(e)).join( " " )})`
    | IndirectInvoke(n, es) -> `(<indirect:${n}> ${es.map( e -> this.expression(e)).join( " " )})`
    }
  }

  mutable fun statement(st: Stmt): String {
    st match {
    | Set(n, e) -> `${this.expression(n)} = ${this.expression(e)}`
    | GSet(n, e) -> `${this.expression(n)} ^= ${this.expression(e)}`
    | ArrSet(n, i, e) -> `${this.expression(n)}[${this.expression(i)}] = ${this.expression(e)}`
    | GArrSet(n, i, e) -> `${this.expression(n)}[${this.expression(i)}] ^= ${this.expression(e)}`
    | Loop(e, s) -> {
      this.inc();
      str = this.code(s);
      this.dec();

      "while " + this.expression(e) + str
    }
    | Branch(e, s1, s2) -> {
      this.inc();
      str1 = this.code(s1);
      str2 = this.code(s2);
      this.dec();

      `(if ${this.expression(e)}\n` +
        str1 + "\n" +
        str2 + ")"
    }
    | Return(e) -> `return ${this.expression(e)}`
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }

}

extension class .Vector {
  fun cat<S : T>( item: S ): this {
    this.concat( Vector<T>[ item ] )
  }
}

module end;
