module Reader;

type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;
type VMap = mutable Map<String, String>;
type Exprs = Vector<Expr>;

value class Module(name: String, imports: Strings, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Code, locals: Int) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
  | Set(Register, Exp)
  | GSet(Register, Exp)
  | ArrSet(Register, Exp, Exp) // Register with array, index and value
  | GArrSet(Register, Exp, Exp)
  | Loop(Exp, Code)
  | Branch(Exp, Code, Code)
  | Return(Exp) // TODO: Return(Register)
  //this means that the Flattener needs to turn the last expression in
  //Function into a return (and store the result into the register
  //first).  This will be helped when we check sanity of function
  //definitions. See comment on top of Checker.sk

  fun toString(): String {
	  this match {
     | Set(r, e) -> `(set! ${r.toString()} ${e.toString()})`
     | GSet(r, e) -> `(gset! ${r.toString()} ${e.toString()})`
     | ArrSet(r, i, e) -> `(arr_set! ${r.toString()} ${i.toString()} ${e.toString()})`
     | GArrSet(r, i, e) -> `(garr_set! ${r.toString()} ${i.toString()} ${e.toString()})`
     | Loop(e, _c) -> `(while (${e.toString()}) ... )`
     | Branch(e, _, _) -> `(if (${e.toString()} (...) (...))`
     | Return(e) -> `(ret ${e.toString()} )`
    }
  }
}

base class Exp {
  children =
  | VInt(Int)
  | VBool(Bool)
  | VString(String)
  | VChar(Char)
  | VList(content: Vector<Register>)
  | Register(name: String) // TODO integer
  | Load(String) // TODO: can all loads be statements? would make expr simpler, but we already have invoke
  | Invoke(String, Vector<Register>)

  fun toString(): String {
	  this match {
     | VInt(v) -> `${v}`
     | VBool(v) -> `${v}`
     | VString(v) -> `${v}`
     | VChar(v) -> `${v}`
     | VList(_v) -> `[...]`
     | Register(name) -> `${name}`
     | Load(v)  -> `g${v}`
     | Invoke(f, _vs) -> `(${f} ...)`
		}
  }
}

mutable class .Flattener(mutable v: Int = 0, glob: VMap = Map::mcreate(), funs: mutable Functions = mutable Functions[]) {

  // Adds all global variables to the scope and creates a init function with initialization values
  mutable fun handleGlobals(f: File): Function {
    // Body of the init function
    v = mutable Exprs[];

    // For each global variable -> add it to scope and add a initialization statement to the body
    f.decls.each(d -> d match { | Decl(t, n, e) -> {
      this.glob.add( n, this.nextVar() );
      // Does not need to be gset, it is transformed automatically
      v.push( Call(t, "set!", Exprs[ Var(t, n), e ]) )
    }});

    // Return 0
    v.push(LitInt(f.tok, 0));

    b = Block(f.tok, v.chill());

    Function(f.tok,
      "init", // name
      Strings[], // params
      None(), // polyArg
      b, // body
      0 // locals
    )
  }

  mutable fun file(f: File): Module {
    this.glob.clear();
    this.!v = 0;

    this.funs.extend(f.funs);
		// we need to preserve all the functions in all the modules.  even
    // thought, this approach seems to be susceptible to bugs.  the
    // order in which the modules are processed matters, but that
    // order is not really the order of dependencies

    // Handle globals, create the init function
    init = this.handleGlobals(f);

    // Flatten all functions
    funs = Vector::mcreateFromItems(f.funs);
    funs.push(init);
    fs = funs.map(f -> this.function(f));
    Module( f.name, f.imports, f.decls.size(), fs )
  }

  mutable fun function(f: Function): Fun {
    this.!v = 0;

    // Handle locals, body and parameters
    // is different for polyArg functions
    (locals, body, params) = if (f.polyArg.isSome()) {
      this.polyFunction(f)
    } else {
      locals : VMap = Map::mcreate();
      f.params.each(p -> locals.add(p, this.nextVar()));

      (locals, f.body, f.params)
    };

    (es, e) = this.expression(body, locals);
    e match {
      | None() -> this.fail( f.tok, `Missing return in ${f.name}` )
      | Some(val) -> !es = es.cat( Return(val) )
    };

    Fun( f.name, params.size(), Code( es ), this.v )
  }

  // The parameters of poly function work like this
  // (function foo(a b ...c) body)
  // is rewritten to
  // (function foo(param)
  //  (begin
  //    (let a (at param 0))
  //    (let b (at param 1))
  //    (let c (drop param 2))
  //    body
  //  )
  // )
  // returns (locals, body of the new function, new parameters)
  mutable fun polyFunction(f: Function): (VMap, Expr, Strings) {
    locals: VMap = Map::mcreate();

    aname = this.nextVar();
    argVar = Var(f.tok, aname);
    locals.add(aname, aname);

    // rewrite all the parameters into something like
    // Decl(<original token>, <original name>, Call(<original token>, "at", Vector[<original name>, <position>]))
    // this needs to become a part of the body of the function, so I need to prepend it before transformation
    unlistParams = f.params.mapWithIndex((pos, name) ->
      Decl(f.tok, name, Call(f.tok, "at", Exprs[argVar, LitInt(f.tok, pos)]))
    );

    // all of this will go into a body
    // they "redefine" original parameters and we make up a new, singular parameter (inside `argVar`)
    unlistRest = f.polyArg.map(str ->
      Exprs[Decl(f.tok,str, Call(f.tok, "drop", Exprs[LitInt(f.tok, f.params.size()), argVar]))]
    ).default(Exprs[]);

    body = mutable Exprs[];
    body.extend(unlistParams);
    body.extend(unlistRest);
    body.push(f.body);

    bodyExpr = Block(f.tok, body.chill());
    params = Strings[aname]; // There's always just this one "arguments"

    (locals, bodyExpr, params)
  }

  /*****************************************/
  // helpers

  readonly fun fail<T>(tok: Tok, message: String): T {
    errMsg = tok.error_message(message);
    invariant_violation( errMsg );
  }

  readonly fun arityOf(fname: String): Arity {
    this.funs.find(f -> f.name == fname) match {
      | Some(f) ->
          f.polyArg match {
            | None() -> Exactly(f.params.size())
            | Some(_) -> AtLeast(f.params.size())
          }
      | None() -> NotAFunction()
    }
  }

  readonly fun asVar(e: Expr): (Tok, String) {
    e match {
      | Var(t, s) -> (t, s)
      | _ -> this.fail(e.getToken(), "Not a variable" )
    }
  }

  mutable fun nextVarId(): Int {
     id = this.v;
    this.!v = this.v + 1;
    id
  }

  mutable fun nextVar(): String { `%${this.nextVarId()}` }

  readonly fun toRegister(t: Tok, varname: String, locals: VMap): String {
    if (locals.containsKey(varname)) {
      locals.get(varname)
    } else if (this.glob.containsKey(varname)) {
      this.glob.get(varname)
    } else {
      this.fail( t, `Variable name ${varname} no found in any scope` ) //TODO
    }
  }

  /*****************************************/
  // Expression flattening

  mutable fun literal(exp: Exp): (Statements, Option<Register>) {
    reg = Register( this.nextVar() );
    set = Statements[ Set( reg, exp ) ];
    (set, Some(reg))
  }

  // An expression where we enforce that the return register is present
  mutable fun expressionVal(e0: Expr, locals: VMap): (Statements, Register) {
    (v2, e2) = this.expression(e0, locals);
    e2 match {
      | Some(val) -> (v2, val)
      | None() -> this.fail( Tok(), "?") //TODO
    }
  }

  // Returns pair of the code and the last register where the return value is in
  mutable fun expression(e0: Expr, locals: VMap): (Statements, Option<Register>) {
    e0 match {
    | LitInt(_, i) ->    this.literal( VInt(i) )
    | LitBool(_, b) ->   this.literal( VBool(b) )
    | LitChar(_, c) ->   this.literal( VChar(c) )
    | LitString(_, s) -> this.literal( VString(s) )
    | LitList(t, _) -> {
      this.fail( t, "Encountered a list in Flattener" )
    }
    | Var(t, n) -> {
      vname = this.toRegister(t, n, locals);
      if (locals.containsKey(n)) {
        (Statements[], Some(Register(vname)))
      } else if (this.glob.containsKey(n)) {
        // if some variable x is global, it is transformed to
        // x_ = load x
        // and then 'x_' is used from this point on
        register = Register( this.nextVar() );
        assign = Set(register, Load( vname ));
        (Statements[ assign ], Some(register))
      } else {
        this.fail( t, "Unknown variable" )
      }
    }
    | Decl(_, n, e) -> {
      (exprBody, exprResult) = this.expressionVal(e, locals);
      varname = this.nextVar();
      locals.add(n, varname);

      set = Set( Register(varname), exprResult );
      (exprBody.cat(set), None())
    }
    | Call(t, "set!", es) -> {
      // (set! var assign)
      // is transformed to
      // assignResult = evaluated assign
      // var = assignResult
      (_, origVName) = this.asVar( es[0] );

      destRegister = Register( this.toRegister(t, origVName, locals));
      (assignBody, assignResult) = this.expressionVal(es[1], locals);

      set = if(this.glob.containsKey(origVName)){
        GSet( destRegister, assignResult );
      } else {
        Set( destRegister, assignResult );
      };

      (assignBody.cat(set), None())
    }
    | Call(t, "arr_set!", es) -> {
      // (arr_set! var idx assign)
      // is transformed to
      // idxResult = evaluated idx
      // assignResult = evaluated assign
      // var[idxResult] = assignResult
      (_, origVName) = this.asVar( es[0] );

      destRegister = Register( this.toRegister(t, origVName, locals));

      (idxBody, idxResult) = this.expressionVal(es[1], locals);
      (assignBody, assignResult) = this.expressionVal(es[2], locals);

      set = if(this.glob.containsKey(origVName)){
        GArrSet( destRegister, idxResult, assignResult )
      } else {
        ArrSet( destRegister, idxResult, assignResult )
      };

      (idxBody.concat(assignBody).cat(set) , None())
    }
    | Call(t, n, es) -> {
      this.arityOf(n) match {
        | NotAFunction() -> this.fail( t, "Calling not a function" )
        | Exactly(_) -> {
          body = mutable Statements[];
          params = mutable Vector<Register>[];

          es.each(e -> {
            (paramBody, param) = this.expressionVal(e, locals);
            body.extend(paramBody);
            params.push(param);
          });

          returnRegister = Register( this.nextVar() );
          call = Invoke( n, params.chill() );
          set = Set( returnRegister, call );
          body.push(set);

          (body.chill(), Some(returnRegister))
        }
        | AtLeast(_) -> this.vacall(n, es, locals) // TODO
      }
    }
    | Block(_, es) -> {
      body = mutable Statements[];
      last: Option<Register> = None();

      es.each(e -> {
        (nestedBody, res) = this.expression(e, locals);
        body.extend(nestedBody);
        !last = res
      });

      (body.chill(), last)
    }
    | While(_, e, s) -> {
      // (while expr body)
      // is transformed to
      // condVar = expr
      // loop condVar (
      //  body
      //  condVar = expr
      // )
      (condExpr, condVar) = this.expressionVal(e, locals);
      (whileBody, _) = this.expression(s, locals);

      loopStat = Loop(condVar, Code( whileBody.concat(condExpr) ));

      (condExpr.cat(loopStat), None())
    }
    | Cond(_, e, s1, s2) -> {
      // (if expr trueBody falseBody)
      // is transformed to
      // condVar = expr
      // if (condVar) {res = evaluated trueBody}
      // else {res = evaluated falseBody}
      // and the value of this statement is `res`
      (condExpr, condVar) = this.expressionVal(e, locals);
      (trueBlock, trueRes) = this.expression(s1, locals);
      (falseBlock, falseRes) = this.expression(s2, locals);

      res = (trueRes, falseRes) match {
        | (Some(tVal), Some(fVal)) -> {
          returnReg = Register( this.nextVar() );
          !trueBlock  = trueBlock.cat(  Set(returnReg, tVal) );
          !falseBlock = falseBlock.cat( Set(returnReg, fVal) );
          Some(returnReg)
        }
        | _ -> None()
      };

      branch = Branch( condVar, Code(trueBlock), Code(falseBlock) );
      (condExpr.cat(branch), res)
    }
    };
  }

  // TODO merge with normal fun call
  mutable fun vacall( n: String, es: Exprs, locals: VMap): (Statements, Option<Register>) {
    // that `ordCnt` must be smaller than `argsCnt`, but at
    // this point it will I will have to construct a new
    // variable and store a list in it that list will contain
    // all the additional arguments (rest of `es`) so I take
    // first `n` arguments and deal with them the same way as
    // above but then I create a new variable after I deal
    // with the rest of the arguments in such a way that the
    // new variable can host a List that contains all the
    // second parts of each tuple I then construct the call,
    // it will be almost exactly what is above, but I will
    // push one more argument to it that will be the new
    // variable with the list

    // we know that every polyvariadic function is translated
    // into a function with a single parameter we therefore
    // need to put all the arguments into a list and only pass
    // that list into the call

    // TODO: there are no ordinary arguments, everything goes into a list together with the rest thing
    // ordinary = es.slice(0, ordCnt); // only first `n` arguments
    // ordinary.each(e -> {
    //   (v2, e2) = this.expression(e, locals);
    //   es2.push(e2);
    //   ve.extend(v2.chill());
    // });

    body = mutable Statements[];

    // all original arguments will be flattened and put into a list-value
    // (foo a b c) will transform to
    // %0 = a
    // %1 = b
    // %2 = c
    // %3 = [a b c]
    // returnReg = foo %3
    // where %3 is listvarname
    listvars = mutable Vector<Register>[];
    es.each(e -> {
      (paramBody, param) = this.expressionVal(e, locals);
      listvars.push(param);
      body.extend(paramBody);
    });

    // Add the list variable as declaration
    listreg = Register( this.nextVar() );
    body.push( Set(listreg, VList( listvars.chill())) );

    returnRegister = Register( this.nextVar() ); // Call result variable
    call = Invoke( n, Vector<Register>[ listreg ] );
    set = Set( returnRegister, call );
    body.push(set);

    (body.chill(), Some(returnRegister))
  }
}

mutable class .TranslatedPrettyPrint(mutable indent: Int = 0) {

  static fun prettyPrint(m: Module): String {
    pp = mutable TranslatedPrettyPrint();
    pp.toModule( m )
  }

  readonly fun pad(): String {
    s = "";  n = this.indent;
    while (n > 0) { !s = s + " "; !n = n - 1; };
    s
  }

  mutable fun toModule(f: Module): String {
    s = `(module ${f.name} imports (`;
    f.imports.each(s -> !s = s + s + " ");
    // !s = `${s})\n(vars (`;
    !s = s + `(functions (`;
    if (f.funs.size() == 0) {
      !s = s + "))\n";
    } else {
      this.inc();
      f.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
       !s = s + "\n))\n";
      this.dec();
    };
    s
  }

  mutable fun function(f: Fun): String {
    params = `${f.params}`;
    s = `(function ${f.name}(${params} | ${f.locals}`;
    !s = s + ") ";
    this.inc();
    !s = s + this.code(f.body);
    this.dec();
    !s = s + ")\n";
    s
  }

  mutable fun code(c: Code): String {
    res = "";
    c.stmts.each(s -> {
      !res = res + "\n" + this.pad() + this.statement(s);
    });
    res
  }

  mutable fun expression(e0: Exp): String {
    e0 match {
    | VInt(i) -> `${i}`
    | VBool(b) -> `${b}`
    | VString(s) -> `"${s}"`
    | VChar(ch) -> `'${ch}'`
    | VList(regs) -> `[${regs.map( r -> this.expression(r) ).join( ", " )}]`
    | Register(s) -> s
    | Load(s) -> `load ${s}`
    | Invoke(n, es) -> `(${n} ${es.map( e -> this.expression(e)).join( " " )})`
    }
  }

  mutable fun statement(st: Stmt): String {
    st match {
    | Set(n, e) -> `${this.expression(n)} = ${this.expression(e)}`
    | GSet(n, e) -> `${this.expression(n)} ^= ${this.expression(e)}`
    | ArrSet(n, i, e) -> `${this.expression(n)}[${this.expression(i)}] = ${this.expression(e)}`
    | GArrSet(n, i, e) -> `${this.expression(n)}[${this.expression(i)}] ^= ${this.expression(e)}`
    | Loop(e, s) -> "while " + this.expression(e) + " " + this.code(s)
    | Branch(e, s1, s2) -> {
      s = "(if " + this.expression(e) + "\n";
      this.inc();
      !s = s + this.code(s1) + "\n" + this.code(s2) + ")";
      this.dec();
      s
    }
    | Return(e) -> `return ${this.expression(e)}`
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }

}

extension class .Vector {
  fun cat<S : T>( item: S ): this {
    this.concat( Vector<T>[ item ] )
  }
}

module end;
