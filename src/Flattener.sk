module Reader;

type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;
type VMap = mutable Map<String, String>;
type Exprs = Vector<Expr>;

value class Module(name: String, imports: Strings, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Code, locals: Int) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
  | Set(Register, Exp)
  | GSet(Register, Exp)
  | ArrSet(Register, Exp, Exp) // Register with array, index and value
  | GArrSet(Register, Exp, Exp)
  | Loop(Exp, Code)
  | Branch(Exp, Code, Code)
  | Return(Exp) // TODO: Return(Register)
  //this means that the Flattener needs to turn the last expression in
  //Function into a return (and store the result into the register
  //first).  This will be helped when we check sanity of function
  //definitions. See comment on top of Checker.sk

  fun toString(): String {
	  this match {
     | Set(r, e) -> `(set! ${r.toString()} ${e.toString()})`
     | GSet(r, e) -> `(gset! ${r.toString()} ${e.toString()})`
     | ArrSet(r, i, e) -> `(arr_set! ${r.toString()} ${i.toString()} ${e.toString()})`
     | GArrSet(r, i, e) -> `(garr_set! ${r.toString()} ${i.toString()} ${e.toString()})`
     | Loop(e, _c) -> `(while (${e.toString()}) ... )`
     | Branch(e, _, _) -> `(if (${e.toString()} (...) (...))`
     | Return(e) -> `(ret ${e.toString()} )`
    }
  }
}

base class Exp {
  children =
  | VInt(Int)
  | VBool(Bool)
  | VString(String)
  | VChar(Char)
  | VList(content: Vector<Register>)
  | Register(name: String)
  | Load(String) // TODO: can all loads be statements? would make expr simpler, but we already have invoke
  | Invoke(String, Vector<Register>)

  fun toString(): String {
	  this match {
     | VInt(v) -> `${v}`
     | VBool(v) -> `${v}`
     | VString(v) -> `${v}`
     | VChar(v) -> `${v}`
     | VList(_v) -> `[...]`
     | Register(name) -> `${name}`
     | Load(v)  -> `g${v}`
     | Invoke(f, _vs) -> `(${f} ...)`
		}
  }
}


class .Translator() {

  fun file(f: File): Module {
    globals = f.decls.size();
    funs = f.funs.map(f -> this.function(f));
    Module(f.name, f.imports, globals, funs)
  }

  fun expression(e0: Expr): Exp {
    e0 match {
     | LitInt(_, i) -> VInt(i)
     | LitBool(_, b) -> VBool(b)
     | LitChar(_, c) -> VChar(c)
     | LitString(_, s) -> VString(s)
     | LitList(_, exs) -> VList(exs.map(e -> this.var(e)))
     | Var(_, s) -> Register(s)
     | Call(_, n, es) -> {
        if (n == "load") {
          regName = es[0] match { Var(_, name) -> name | _ -> "ERROR" };
          Load(regName)
        } else {
          args = es.map(e -> e match { | Var(_, n1) -> Register(n1) | _ -> Register("ERROR") });
          Invoke(n, args)
        }
     }
     | _ -> VInt(0)
    }
  }

  fun statement(e0: Expr): Statements {
    e0 match {
    | Call(_, n, es) -> {
      s = n match {
        | "set!" -> Set(this.var(es[0]), this.expression(es[1]))
        | "gset!" -> GSet(this.var(es[0]), this.expression(es[1]))
        | "arr_set!" -> ArrSet(this.var(es[0]), this.expression(es[1]), this.expression(es[2]))
        | "garr_set!" -> GArrSet(this.var(es[0]), this.expression(es[1]), this.expression(es[2]))
        | _ -> Set(Register("ERROR"), VInt(0))
      };
      Statements[s]
    }
    | Decl(_, n, e) -> Statements[Set(Register(n), this.expression(e))]
        | Block(_t, es) -> es.map(e -> this.statement(e)).flatten()
        | While(_, e, s) -> Statements[Loop(this.expression(e), Code(this.statement(s)))]
        | Cond(_, e, s1, s2) -> Statements[Branch(this.expression(e),
                                         Code(this.statement(s1)), Code(this.statement(s2)))]
    | e -> Statements[Return(this.expression(e))]
    }
  }

  fun var(e: Expr): Register {
    e match { | Var(_, str) -> Register(str) | _ -> Register("ERROR") }
  }

  fun function(f: Function): Fun { Fun(f.name, f.params.size(), Code(this.statement(f.body)), f.locals)  }
}



mutable class .Flattener(mutable v: Int = 0, glob: VMap = Map::mcreate(), mutable funs: Functions = Functions[]) {

  mutable fun file(f: File): File {
    this.glob.clear();
    this.!v = 0;

    newFuns = mutable Functions[];
    newFuns.extend(this.funs);
    newFuns.extend(f.funs);
    this.!funs = newFuns.chill();
		// we need to preserve all the functions in all the modules.  even
    // thought, this approach seems to be susceptible to bugs.  the
    // order in which the modules are processed matters, but that
    // order is not really the order of dependencies

    f.decls.each(d -> d match { | Decl(_, n, _) -> { this.glob.add(n, this.nextVar());}});
    v = mutable Exprs[];
    v.extend(f.decls.map(d -> d match { | Decl(t, n, e) -> Call(t, "gset!", Exprs[Var(t, n), e])}));
    varname = "success";
    v.extend(Exprs[Decl(f.tok, varname, LitInt(f.tok, 0)), Var(f.tok, varname)]); // return 0
    b = Block(f.tok, v.chill());
    init = Function(f.tok, "init", Strings[], None(), b, this.v);
    funs = Vector::mcreateFromItems(f.funs);
    funs.push(init);
    fs = funs.map(f -> this.function(f));
    File(f.tok, f.name, f.imports, f.decls, fs)
  }

  mutable fun function(f: Function): Function {
    locals : VMap = Map::mcreate();
    this.!v = 0;
    if (f.polyArg.isSome()) {
      this.polyFunction(f)
    } else {
      f.params.each(p -> locals.add(p, this.nextVar()));
      _ = f.polyArg.map(str -> locals.add(str, this.nextVar()));
      (es, e) = this.expression(f.body, locals);
      Function(f.tok, f.name, f.params, f.polyArg, this.toBlock(f.tok, es, e), this.v)
    }
  }

  mutable fun polyFunction(f: Function): Function {
    locals : VMap = Map::mcreate();
    this.!v = 0; // just to show that it's done

    origParamCnt = f.params.size();
    if (f.polyArg.isSome()) { !origParamCnt = origParamCnt + 1; };

    aname = this.nextVar();
    argVar = Var(f.tok, aname);
    locals.add(aname, aname);

    // rewrite all the parameters into something like
    // Decl(<original token>, <original name>, Call(<original token>, "at", Vector[<original name>, <position>]))
    // this needs to become a part of the body of the function, so I need to prepend it before transformation
    unlistParams
      = f.params.mapWithIndex((pos, name) -> Decl(f.tok, name, Call(f.tok, "at", Exprs[argVar, LitInt(f.tok, pos)])));
    // all of this will go into a body
    // they "redefine" original parameters and we make up a new, singular parameter (inside `argVar`)

    unlistRest = f.polyArg.map(str -> Exprs[Decl(f.tok,str,
							 Call(f.tok, "drop", Exprs[LitInt(f.tok, f.params.size()), argVar]))]).default(Exprs[]);

    body = mutable Exprs[];
    body.extend(unlistParams);
    body.extend(unlistRest);
    body.push(f.body);

    (es, e) = this.expression(Block(f.tok, body.chill()), locals);

    params = Strings[aname]; // There's always just this one "arguments"

    Function(f.tok, f.name, params, None(), this.toBlock(f.tok, es, e), this.v)
  }

  readonly fun arityOf(fname: String): Arity {
    this.funs.find(f -> f.name == fname) match {
      | Some(f) ->
          f.polyArg match {
            | None() -> Exactly(f.params.size())
            | Some(_) -> AtLeast(f.params.size())
          }
      | None() -> // WILL NEVER HAPPEN
          Exactly(-1)
    }
  }

  readonly fun undef(): Expr { Var(Tok(), " Error") }

  readonly fun isUndef(e : Expr): Bool { e match { | Var(_,s) -> s == " Error" | _ -> false } }

  mutable fun nextVarId(): Int {
     id = this.v;
    this.!v = this.v + 1;
    id
  }

  mutable fun nextVar(): String { `%${this.nextVarId()}` }

  readonly fun toBlock(t: Tok, es: mutable Exprs, e: Expr): Expr {
    if (!this.isUndef(e)) { es.push(e);  };
    if (es.size() > 1) { Block(t, es.chill()) } else if (es.size() == 1) { es[0]} else { this.undef() }
   }

  readonly fun toRegister(varname: String, locals: VMap): String {
    if (locals.containsKey(varname)) {
      locals.get(varname)
    } else if (this.glob.containsKey(varname)) {
      this.glob.get(varname)
    } else {
      varname
    }
  }

  mutable fun expression(e0: Expr, locals: VMap): (mutable Exprs, Expr) {
    ve = mutable Exprs[];
    undef = this.undef();
    e0 match {
    | LitInt(t, _)
    | LitBool(t, _)
    | LitChar(t, _)
    | LitString(t, _) -> {
      varname = this.nextVar();
      (mutable Exprs[Decl(t, varname, e0)], Var(t, varname))
    }
    | LitList(t, _) -> {
      // THIS WILL NEVER HAPPEN
      ve.push(Var(t, "ERROR"));
      (ve, undef)
    }
    | Var(t, n) -> {
      vname = this.toRegister(n, locals);
      if (locals.containsKey(n)) {
        (ve, Var(t, vname))
      } else if (this.glob.containsKey(n)) {
        x = Call(t, "load", Exprs[Var(t, vname)]);
        nvar = this.nextVar();
        assign = Decl(t, nvar, x);
        ve.push(assign);
        (ve, Var(t, nvar))
      } else {
        (ve, undef)
      }
    }
    | Decl(t, n, e) -> {
      (v2, e2) = this.expression(e, locals);
      varname = this.nextVar();
      locals.add(n, varname);
      v2.push(Decl(t, varname, e2));
      (v2, undef)
    }
    | Call(t, n@"set!", es) -> {
      (tok, origVName) = es[0] match {| Var(t2, nm) -> (t2, nm) | _ -> (t, "Error")};
      if (this.glob.containsKey(origVName)) {
        !n = "gset!"
      };
      vname = this.toRegister(origVName, locals);
      (v2, e2) = this.expression(es[1], locals);
      args = Exprs[Var(tok, vname), e2];
      v2.push(Call(t, n, args));
      (v2, undef)
    }
    | Call(t, n@"gset!", es) -> {
      (tok, origVName) = es[0] match {| Var(t2, nm) -> (t2, nm) | _ -> (t, "Error")};
      vname = this.toRegister(origVName, locals);
      (v2, e2) = this.expression(es[1], locals);
      args = Exprs[Var(tok, vname), e2];
      v2.push(Call(t, n, args));
      (v2, undef)
    }
    | Call(t, n@"arr_set!", es) -> {
      (tok, origVName) = es[0] match {| Var(t2, nm) -> (t2, nm) | _ -> (t, "Error")};
      if (this.glob.containsKey(origVName)) {
        !n = "garr_set!"
      };
      vname = this.toRegister(origVName, locals);
      (v2, e2) = this.expression(es[1], locals);
      (v3, e3) = this.expression(es[2], locals);
      args = Exprs[Var(tok, vname), e2, e3];
      v2.extend(v3);
      v2.push(Call(t, n, args));
      (v2, undef)
    }
    | Call(t, n, es) -> {
      es2 = mutable Exprs[];
      _argsCnt = es.size();
      arity = this.arityOf(n);
      arity match {
        | NotAFunction() -> invariant_violation( "NotAFunction" ) // TODO
        | Exactly(_) -> {
          // that `n` must be equal to `argsCnt`, but at this point it will
          es.each(e -> {
            (v2, e2) = this.expression(e, locals);
            es2.push(e2);
            ve.extend(v2.chill());
          });
          varname = this.nextVar();
          ve.push(Decl(t, varname, Call(t, n, es2.chill())));
          (ve, Var(t,varname))
        }
        | AtLeast(_) -> {
          // that `ordCnt` must be smaller than `argsCnt`, but at
          // this point it will I will have to construct a new
          // variable and store a list in it that list will contain
          // all the additional arguments (rest of `es`) so I take
          // first `n` arguments and deal with them the same way as
          // above but then I create a new variable after I deal
          // with the rest of the arguments in such a way that the
          // new variable can host a List that contains all the
          // second parts of each tuple I then construct the call,
          // it will be almost exactly what is above, but I will
          // push one more argument to it that will be the new
          // variable with the list

          // we know that every polyvariadic function is translated
          // into a function with a single parameter we therefore
          // need to put all the arguments into a list and only pass
          // that list into the call

          // TODO: there are no ordinary arguments, everything goes into a list together with the rest thing
          // ordinary = es.slice(0, ordCnt); // only first `n` arguments
          // ordinary.each(e -> {
          //   (v2, e2) = this.expression(e, locals);
          //   es2.push(e2);
          //   ve.extend(v2.chill());
          // });

          // rest = es.slice(ordCnt); // until the end
          listvars = mutable Exprs[];
          // all original arguments will be flattened and put into a list-value
          es.each(e -> {
            (v2, e2) = this.expression(e, locals);
            listvars.push(e2);
            ve.extend(v2.chill());
          });
          listvarname = this.nextVar();
          ve.push(Decl(t, listvarname, LitList(t, listvars.chill())));
          es2.push(Var(t, listvarname));
          varname = this.nextVar();
          ve.push(Decl(t, varname, Call(t, n, es2.chill())));
          (ve, Var(t,varname))
        }
      }
    }
    | Block(_, es) -> {
      last = undef;
      es.each(e -> {
        (v2, e2) =  this.expression(e, locals);
        ve.extend(v2.chill());
        !last = e2;
      });
      (ve, last)
    }
    | While(t, e, s) -> {
      (v2, e2) = this.expression(e, locals);
      ve.extend(v2.chill());
      (v3, _) = this.expression(s, locals);
      v3.extend(v2.chill());
      ve.push(While(t, e2, this.toBlock(t, v3,  undef)));
      (ve, undef)
    }
    | Cond(t, e, s1, s2) -> {
      (v2, e2) = this.expression(e, locals);
      ve.extend(v2.chill());
      (v3, _) = this.expression(s1, locals);
      (v4, _) = this.expression(s2, locals);
      ve.push(Cond(t, e2, this.toBlock(t, v3, undef), this.toBlock(t, v4, undef)));
      (ve, undef)
    }
    }
  }
}



mutable class .TranslatedPrettyPrint(mutable indent: Int = 0) {

  static fun prettyPrint(m: Module): String {
    pp = mutable TranslatedPrettyPrint();
    pp.toModule( m )
  }

  readonly fun pad(): String {
    s = "";  n = this.indent;
    while (n > 0) { !s = s + " "; !n = n - 1; };
    s
  }

  mutable fun toModule(f: Module): String {
    s = `(module ${f.name} imports (`;
    f.imports.each(s -> !s = s + s + " ");
    // !s = `${s})\n(vars (`;
    !s = s + `(functions (`;
    if (f.funs.size() == 0) {
      !s = s + "))\n";
    } else {
      this.inc();
      f.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
       !s = s + "\n))\n";
      this.dec();
    };
    s
  }

  mutable fun function(f: Fun): String {
    params = `${f.params}`;
    s = `(function ${f.name}(${params} | ${f.locals}`;
    !s = s + ") ";
    this.inc();
    !s = s + this.code(f.body);
    this.dec();
    !s = s + ")\n";
    s
  }

  mutable fun code(c: Code): String {
    res = "";
    c.stmts.each(s -> {
      !res = res + "\n" + this.pad() + this.statement(s);
    });
    res
  }

  mutable fun expression(e0: Exp): String {
    e0 match {
    | VInt(i) -> `${i}`
    | VBool(b) -> `${b}`
    | VString(s) -> `"${s}"`
    | VChar(ch) -> `'${ch}'`
    | VList(regs) -> `[${regs.map( r -> this.expression(r) ).join( ", " )}]`
    | Register(s) -> s
    | Load(s) -> `load ${s}`
    | Invoke(n, es) -> `(${n} ${es.map( e -> this.expression(e)).join( " " )})`
    }
  }

  mutable fun statement(st: Stmt): String {
    st match {
    | Set(n, e) -> `${this.expression(n)} = ${this.expression(e)}`
    | GSet(n, e) -> `${this.expression(n)} ^= ${this.expression(e)}`
    | ArrSet(n, i, e) -> `${this.expression(n)}[${this.expression(i)}] = ${this.expression(e)}`
    | GArrSet(n, i, e) -> `${this.expression(n)}[${this.expression(i)}] ^= ${this.expression(e)}`
    | Loop(e, s) -> "while " + this.expression(e) + " " + this.code(s)
    | Branch(e, s1, s2) -> {
      s = "(if " + this.expression(e) + "\n";
      this.inc();
      !s = s + this.code(s1) + "\n" + this.code(s2) + ")";
      this.dec();
      s
    }
    | Return(e) -> `return ${this.expression(e)}`
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }

}

module end;
