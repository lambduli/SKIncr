module Reader;

type Funs = Vector<Fun>;
type Statements = Vector<Stmt>;
type VMap = mutable Map<String, String>;
type Exprs = Vector<Expr>;

value class Module(name: String, imports: Strings, globs: Int, funs: Funs) {}
value class Fun(name: String, params: Int, body: Code, locals: Int) {}
value class Code(stmts: Statements) {}

base class Stmt {
  children =
  | Set(Register, Exp)
  | GSet(Register, Exp)
  | ArrSet(Register, Exp, Exp) // Register with array, index and value
  | GArrSet(Register, Exp, Exp)
  | Loop(Exp, Code)
  | Branch(Exp, Code, Code)
  | Return(Exp) // TODO: Return(Register)
  //this means that the Flattener needs to turn the last expression in
  //Function into a return (and store the result into the register
  //first).  This will be helped when we check sanity of function
  //definitions. See comment on top of Checker.sk

  fun toString(): String {
	  this match {
     | Set(r, e) -> `(set! ${r.toString()} ${e.toString()})`
     | GSet(r, e) -> `(gset! ${r.toString()} ${e.toString()})`
     | ArrSet(r, i, e) -> `(arr_set! ${r.toString()} ${i.toString()} ${e.toString()})`
     | GArrSet(r, i, e) -> `(garr_set! ${r.toString()} ${i.toString()} ${e.toString()})`
     | Loop(e, _c) -> `(while (${e.toString()}) ... )`
     | Branch(e, _, _) -> `(if (${e.toString()} (...) (...))`
     | Return(e) -> `(ret ${e.toString()} )`
    }
  }
}

base class Exp {
  children =
  | VInt(Int)
  | VBool(Bool)
  | VString(String)
  | VChar(Char)
  | VList(content: Vector<Register>)
  | Register(name: String) // TODO integer
  | Load(String) // TODO: can all loads be statements? would make expr simpler, but we already have invoke
  | Invoke(String, Vector<Register>)

  fun toString(): String {
	  this match {
     | VInt(v) -> `${v}`
     | VBool(v) -> `${v}`
     | VString(v) -> `${v}`
     | VChar(v) -> `${v}`
     | VList(_v) -> `[...]`
     | Register(name) -> `${name}`
     | Load(v)  -> `g${v}`
     | Invoke(f, _vs) -> `(${f} ...)`
		}
  }
}


class .Translator() {

  fun file(f: File): Module {
    globals = f.decls.size();
    funs = f.funs.map(f -> this.function(f));
    Module(f.name, f.imports, globals, funs)
  }

  fun expression(e0: Expr): Exp {
    e0 match {
     | LitInt(_, i) -> VInt(i)
     | LitBool(_, b) -> VBool(b)
     | LitChar(_, c) -> VChar(c)
     | LitString(_, s) -> VString(s)
     | LitList(_, exs) -> VList(exs.map(e -> this.var(e)))
     | Var(_, s) -> Register(s)
     | Call(_, n, es) -> {
        if (n == "load") {
          regName = es[0] match { Var(_, name) -> name | _ -> "ERROR" };
          Load(regName)
        } else {
          args = es.map(e -> e match { | Var(_, n1) -> Register(n1) | _ -> Register("ERROR") });
          Invoke(n, args)
        }
     }
     | _ -> VInt(0)
    }
  }

  fun statement(e0: Expr): Statements {
    e0 match {
    | Call(_, n, es) -> {
      s = n match {
        | "set!" -> Set(this.var(es[0]), this.expression(es[1]))
        | "gset!" -> GSet(this.var(es[0]), this.expression(es[1]))
        | "arr_set!" -> ArrSet(this.var(es[0]), this.expression(es[1]), this.expression(es[2]))
        | "garr_set!" -> GArrSet(this.var(es[0]), this.expression(es[1]), this.expression(es[2]))
        | _ -> Set(Register("ERROR"), VInt(0))
      };
      Statements[s]
    }
    | Decl(_, n, e) -> Statements[Set(Register(n), this.expression(e))]
    | Block(_t, es) -> es.map(e -> this.statement(e)).flatten()
    | While(_, e, s) -> Statements[Loop(this.expression(e), Code(this.statement(s)))]
    | Cond(_, e, s1, s2) -> Statements[Branch(this.expression(e),
                                         Code(this.statement(s1)), Code(this.statement(s2)))]
    | e -> Statements[Return(this.expression(e))]
    }
  }

  fun var(e: Expr): Register {
    e match { | Var(_, str) -> Register(str) | _ -> Register("ERROR") }
  }

  fun function(f: Function): Fun { Fun(f.name, f.params.size(), Code(this.statement(f.body)), f.locals)  }
}



mutable class .Flattener(mutable v: Int = 0, glob: VMap = Map::mcreate(), funs: mutable Functions = mutable Functions[]) {

  // Adds all global variables to the scope and creates a init function with initialization values
  mutable fun handleGlobals(f: File): Function {
    // Body of the init function
    v = mutable Exprs[];

    // For each global variable -> add it to scope and add a initialization statement to the body
    f.decls.each(d -> d match { | Decl(t, n, e) -> {
      this.glob.add( n, this.nextVar() );
      // Does not need to be gset, it is transformed automatically
      v.push( Call(t, "set!", Exprs[ Var(t, n), e ]) )
    }});

    // Return 0
    v.push(LitInt(f.tok, 0));

    b = Block(f.tok, v.chill());

    Function(f.tok,
      "init", // name
      Strings[], // params
      None(), // polyArg
      b, // body
      0 // locals
    )
  }

  mutable fun file(f: File): File {
    this.glob.clear();
    this.!v = 0;

    this.funs.extend(f.funs);
		// we need to preserve all the functions in all the modules.  even
    // thought, this approach seems to be susceptible to bugs.  the
    // order in which the modules are processed matters, but that
    // order is not really the order of dependencies

    // Handle globals, create the init function
    init = this.handleGlobals(f);

    // Flatten all functions
    funs = Vector::mcreateFromItems(f.funs);
    funs.push(init);
    fs = funs.map(f -> this.function(f));
    File(f.tok, f.name, f.imports, f.decls, fs)
  }

  mutable fun function(f: Function): Function {
    this.!v = 0;

    // Handle locals, body and parameters
    // is different for polyArg functions
    (locals, body, params) = if (f.polyArg.isSome()) {
      this.polyFunction(f)
    } else {
      locals : VMap = Map::mcreate();
      f.params.each(p -> locals.add(p, this.nextVar()));

      (locals, f.body, f.params)
    };

    (es, e) = this.expression(body, locals);
    _ = this.assertExpression(f.tok, `return of ${f.name}`, e);

    Function(f.tok, f.name, params, None(), this.toBlock(f.tok, es, e), this.v)
  }

  // The parameters of poly function work like this
  // (function foo(a b ...c) body)
  // is rewritten to
  // (function foo(param)
  //  (begin
  //    (let a (at param 0))
  //    (let b (at param 1))
  //    (let c (drop param 2))
  //    body
  //  )
  // )
  // returns (locals, body of the new function, new parameters)
  mutable fun polyFunction(f: Function): (VMap, Expr, Strings) {
    locals: VMap = Map::mcreate();

    aname = this.nextVar();
    argVar = Var(f.tok, aname);
    locals.add(aname, aname);

    // rewrite all the parameters into something like
    // Decl(<original token>, <original name>, Call(<original token>, "at", Vector[<original name>, <position>]))
    // this needs to become a part of the body of the function, so I need to prepend it before transformation
    unlistParams = f.params.mapWithIndex((pos, name) ->
      Decl(f.tok, name, Call(f.tok, "at", Exprs[argVar, LitInt(f.tok, pos)]))
    );

    // all of this will go into a body
    // they "redefine" original parameters and we make up a new, singular parameter (inside `argVar`)
    unlistRest = f.polyArg.map(str ->
      Exprs[Decl(f.tok,str, Call(f.tok, "drop", Exprs[LitInt(f.tok, f.params.size()), argVar]))]
    ).default(Exprs[]);

    body = mutable Exprs[];
    body.extend(unlistParams);
    body.extend(unlistRest);
    body.push(f.body);

    bodyExpr = Block(f.tok, body.chill());
    params = Strings[aname]; // There's always just this one "arguments"

    (locals, bodyExpr, params)
  }

  /*****************************************/
  // helpers

  readonly fun fail<T>(tok: Tok, message: String): T {
    errMsg = tok.error_message(message);
    invariant_violation( errMsg );
  }

  readonly fun arityOf(fname: String): Arity {
    this.funs.find(f -> f.name == fname) match {
      | Some(f) ->
          f.polyArg match {
            | None() -> Exactly(f.params.size())
            | Some(_) -> AtLeast(f.params.size())
          }
      | None() -> NotAFunction()
    }
  }

  readonly fun asVar(e: Expr): (Tok, String) {
    e match {
      | Var(t, s) -> (t, s)
      | _ -> this.fail(e.getToken(), "Not a variable" )
    }
  }

  mutable fun nextVarId(): Int {
     id = this.v;
    this.!v = this.v + 1;
    id
  }

  mutable fun nextVar(): String { `%${this.nextVarId()}` }

  readonly fun toBlock(t: Tok, es: mutable Exprs, e: Option<Expr>): Expr {
    e.each( e -> es.push(e) );

    if (es.size() > 1) {
      Block(t, es.chill())
    } else if (es.size() == 1) {
      es[0]
    } else {
      this.fail( t, "Empty expressions in 'toBlock'" )
    }
   }

  readonly fun toRegister(t: Tok, varname: String, locals: VMap): String {
    if (locals.containsKey(varname)) {
      locals.get(varname)
    } else if (this.glob.containsKey(varname)) {
      this.glob.get(varname)
    } else {
      this.fail( t, `Variable name ${varname} no found in any scope` ) //TODO
    }
  }

  // Makes sure that expr is Some, otherwise fails
  readonly fun assertExpression(t: Tok, name: String, expr: Option<Expr> ): Expr {
    expr match {
      | Some(e) -> e
      | None() -> this.fail( t, `Empty expression result in ${name}` ) // TODO
    }
  }

  /*****************************************/
  // Expression flattening

  // Returns pair of the code and the last variable where the return value is in
  mutable fun expression(e0: Expr, locals: VMap): (mutable Exprs, Option<Expr>) {
    emptyExprs = mutable Exprs[];
    e0 match {
    | LitInt(t, _)
    | LitBool(t, _)
    | LitChar(t, _)
    | LitString(t, _) -> {
      varname = this.nextVar();
      (mutable Exprs[Decl(t, varname, e0)], Some(Var(t, varname)))
    }
    | LitList(t, _) -> {
      this.fail( t, "Encountered a list in Flattener" )
    }
    | Var(t, n) -> {
      vname = this.toRegister(t, n, locals);
      if (locals.containsKey(n)) {
        (emptyExprs, Some(Var(t, vname)))
      } else if (this.glob.containsKey(n)) {
        // if some variable x is global, it is transformed to
        // (let x_ (load x))
        // and then 'x_' is used from this point on
        x = Call(t, "load", Exprs[Var(t, vname)]);
        nvar = this.nextVar();
        assign = Decl(t, nvar, x);
        (mutable Exprs[assign], Some(Var(t, nvar)))
      } else {
        this.fail( t, "Unknown variable" )
      }
    }
    | Decl(t, n, e) -> {
      (v2, e2) = this.expression(e, locals);
      varname = this.nextVar();
      locals.add(n, varname);

      decl = Decl(t, varname, this.assertExpression(t, "let", e2));
      (v2.cat(decl), None())
    }
    | Call(t, n@"set!", es) -> {
      (tok, origVName) = this.asVar( es[0] );
      if (this.glob.containsKey(origVName)) {
        !n = "gset!"
      };
      vname = this.toRegister(t, origVName, locals);

      (v2, e2) = this.expression(es[1], locals);
      args = Exprs[Var(tok, vname), this.assertExpression(t, "set! arg", e2)];
      call = Call(t, n, args);

      (v2.cat(call), None())
    }
    | Call(t, n@"arr_set!", es) -> {
      (tok, origVName) = this.asVar( es[0] );
      if (this.glob.containsKey(origVName)) {
        !n = "garr_set!"
      };
      vname = this.toRegister(t, origVName, locals);

      (v2, e2) = this.expression(es[1], locals);
      (v3, e3) = this.expression(es[2], locals);
      args = Exprs[
        Var(tok, vname),
        this.assertExpression(t, "arr_set! arg1", e2),
        this.assertExpression(t, "arr_set! arg2", e3)
      ];
      call = Call(t, n, args);

      (v2.cats(v3).cat( call ), None())
    }
    | Call(t, n, es) -> {
      this.arityOf(n) match {
        | NotAFunction() -> this.fail( t, "Calling not a function" )
        | Exactly(_) -> {
          // that `n` must be equal to `argsCnt`, but at this point it will
          ve = mutable Exprs[];
          es2 = mutable Exprs [];

          es.each(e -> {
            (v2, e2) = this.expression(e, locals);

            es2.push( this.assertExpression(t, "regular arguments", e2));
            ve.extend(v2);
          });

          varname = this.nextVar();
          ve.push(Decl(t, varname, Call(t, n, es2.chill())));

          (ve, Some(Var(t,varname)))
        }
        | AtLeast(_) -> this.vacall(t, n, es, locals)
      }
    }
    | Block(_, es) -> {
      ve = mutable Exprs[];
      z: Option<Expr> = None(); // Explicitly type the None

      last = es.reduce((_, e) -> {
        (v2, e2) =  this.expression(e, locals);
        ve.extend(v2.chill());
        e2
      }, z);

      (ve, last)
    }
    | While(t, e, s) -> {
      (v2, e2) = this.expression(e, locals);
      (v3, _) = this.expression(s, locals);

      block = this.toBlock(t, v3.cats(v2), None());
      whileExp = While(t, this.assertExpression(t, "while", e2), block);

      (v2.cat(whileExp), None())
    }
    | Cond(t, e, s1, s2) -> {
      (v2, e2) = this.expression(e, locals);
      (v3, _) = this.expression(s1, locals);
      (v4, _) = this.expression(s2, locals);

      trueBlock = this.toBlock(t, v3, None());
      falseBlock = this.toBlock(t, v4, None());
      cond = Cond(t, this.assertExpression(t, "if", e2), trueBlock, falseBlock);
      ve = v2.cat( cond );

      (ve, None())
    }
    };
  }

  mutable fun vacall( t: Tok, n: String, es: Exprs, locals: VMap): (mutable Exprs, Option<Expr>) {
    // that `ordCnt` must be smaller than `argsCnt`, but at
    // this point it will I will have to construct a new
    // variable and store a list in it that list will contain
    // all the additional arguments (rest of `es`) so I take
    // first `n` arguments and deal with them the same way as
    // above but then I create a new variable after I deal
    // with the rest of the arguments in such a way that the
    // new variable can host a List that contains all the
    // second parts of each tuple I then construct the call,
    // it will be almost exactly what is above, but I will
    // push one more argument to it that will be the new
    // variable with the list

    // we know that every polyvariadic function is translated
    // into a function with a single parameter we therefore
    // need to put all the arguments into a list and only pass
    // that list into the call

    // TODO: there are no ordinary arguments, everything goes into a list together with the rest thing
    // ordinary = es.slice(0, ordCnt); // only first `n` arguments
    // ordinary.each(e -> {
    //   (v2, e2) = this.expression(e, locals);
    //   es2.push(e2);
    //   ve.extend(v2.chill());
    // });

    ve = mutable Exprs[]; // output exprs

    // all original arguments will be flattened and put into a list-value
    // (foo a b c) will transform to
    // %0 = a
    // %1 = b
    // %2 = c
    // %3 = [a b c]
    // where %3 is listvarname
    listvars = mutable Exprs[];
    es.each(e -> {
      (v2, e2) = this.expression(e, locals);
      listvars.push(this.assertExpression(Tok(), "vararg arguments", e2));
      ve.extend(v2.chill());
    });

    // Add the list variable as declaration
    listvarname = this.nextVar();
    ve.push(Decl(t, listvarname, LitList(t, listvars.chill())));

    listvarAsVar = Exprs[ Var(t, listvarname) ];
    varname = this.nextVar(); // Call result variable
    ve.push(Decl(t, varname, Call(t, n, listvarAsVar)));

    (ve, Some(Var(t,varname)))
  }
}



mutable class .TranslatedPrettyPrint(mutable indent: Int = 0) {

  static fun prettyPrint(m: Module): String {
    pp = mutable TranslatedPrettyPrint();
    pp.toModule( m )
  }

  readonly fun pad(): String {
    s = "";  n = this.indent;
    while (n > 0) { !s = s + " "; !n = n - 1; };
    s
  }

  mutable fun toModule(f: Module): String {
    s = `(module ${f.name} imports (`;
    f.imports.each(s -> !s = s + s + " ");
    // !s = `${s})\n(vars (`;
    !s = s + `(functions (`;
    if (f.funs.size() == 0) {
      !s = s + "))\n";
    } else {
      this.inc();
      f.funs.each(f -> !s = s + "\n" + this.pad() + this.function(f));
       !s = s + "\n))\n";
      this.dec();
    };
    s
  }

  mutable fun function(f: Fun): String {
    params = `${f.params}`;
    s = `(function ${f.name}(${params} | ${f.locals}`;
    !s = s + ") ";
    this.inc();
    !s = s + this.code(f.body);
    this.dec();
    !s = s + ")\n";
    s
  }

  mutable fun code(c: Code): String {
    res = "";
    c.stmts.each(s -> {
      !res = res + "\n" + this.pad() + this.statement(s);
    });
    res
  }

  mutable fun expression(e0: Exp): String {
    e0 match {
    | VInt(i) -> `${i}`
    | VBool(b) -> `${b}`
    | VString(s) -> `"${s}"`
    | VChar(ch) -> `'${ch}'`
    | VList(regs) -> `[${regs.map( r -> this.expression(r) ).join( ", " )}]`
    | Register(s) -> s
    | Load(s) -> `load ${s}`
    | Invoke(n, es) -> `(${n} ${es.map( e -> this.expression(e)).join( " " )})`
    }
  }

  mutable fun statement(st: Stmt): String {
    st match {
    | Set(n, e) -> `${this.expression(n)} = ${this.expression(e)}`
    | GSet(n, e) -> `${this.expression(n)} ^= ${this.expression(e)}`
    | ArrSet(n, i, e) -> `${this.expression(n)}[${this.expression(i)}] = ${this.expression(e)}`
    | GArrSet(n, i, e) -> `${this.expression(n)}[${this.expression(i)}] ^= ${this.expression(e)}`
    | Loop(e, s) -> "while " + this.expression(e) + " " + this.code(s)
    | Branch(e, s1, s2) -> {
      s = "(if " + this.expression(e) + "\n";
      this.inc();
      !s = s + this.code(s1) + "\n" + this.code(s2) + ")";
      this.dec();
      s
    }
    | Return(e) -> `return ${this.expression(e)}`
    }
  }

  mutable fun inc(): void { this.!indent = this.indent + 2; }
  mutable fun dec(): void { this.!indent = this.indent - 2; }

}

extension mutable class .Vector {
  mutable fun cat( item: T ): mutable this {
    this.push( item );
    this
  }

  mutable fun cats( items: mutable Vector<T> ): mutable this {
    this.extend( items.chill() );
    this
  }
}

module end;
